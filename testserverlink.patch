# HG changeset patch
# Parent f20279c25d5a74d4b9b86e773f2e17cc70453d51

Handle an incoming test server link.

Checks everything a normal server connection is checked for,
a connect block for the server (for server name and host),
password check, check against connnection rules,
and server jupes are checked.

To test server link, send on a server port:
PASS :<pass>
SERVER servername

On servers without this patch, that will be rejected because SERVER requires more parameters.

Handle test server link with separate function as to
minimize messing with mr_server function and
to check things in logical order for a test server link
which is different from logic in mr_server.

diff -r f20279c25d5a ircd/m_server.c
--- a/ircd/m_server.c
+++ b/ircd/m_server.c
@@ -494,6 +494,79 @@
     }
 }
 
+/** Handle a test server link - snircd.
+ *
+ * \a parv has the following elements:
+ * \li \a parv[1] is the server name
+ *
+ * See @ref m_functions for discussion of the arguments.
+ * @param[in] cptr Client that sent us the message.
+ * @param[in] sptr Original source of message.
+ * @param[in] parc Number of arguments.
+ * @param[in] parv Argument vector.
+ */
+int test_server_link(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
+{
+  struct ConfItem* aconf; /* conf item attached to cptr */
+  struct Jupe*     ajupe; /* jupe for server */
+  char             *host; /* cleaned up server name */
+  const char      *crule; /* connection rule disallowing connection */
+  int               jupe; /* server is juped */
+
+  assert(NULL != sptr);
+  assert(NULL != cptr);
+  assert(parc > 1);
+
+  /* check server name */
+  if (!(host = clean_servername(parv[1])))
+    return exit_client_msg(cptr, cptr, &me, "Bogus server name (%s)", parv[1]);
+
+  /* set name */
+  ircd_strncpy(cli_name(cptr), host, HOSTLEN);
+
+  /* check connect block */
+  if (conf_check_server(cptr))
+    return exit_client(cptr, cptr, &me, "No Connect block");
+
+  /* check connect block */
+  if (!(aconf = find_conf_byname(cli_confs(cptr), host, CONF_SERVER)))
+    return exit_client_msg(cptr, cptr, &me,
+                           "Access denied. No conf line for server %s", host);
+
+  /* connect block for server and host checks out,
+   *   from here we can announce the result to opers
+   */
+
+  /* check password */
+  if (*aconf->passwd && strcmp(aconf->passwd, cli_passwd(cptr))) {
+    sendwallto_group_butone(&me, WALL_WALLOPS, 0,
+                            "Server test link from %s failed (passwd mismatch)", host);
+
+    return exit_client_msg(cptr, cptr, &me,
+                           "Server test link %s failed (passwd mismatch)", host);
+  }
+
+  /* connect rules */
+  crule = conf_eval_crule(host, CRULE_ALL);
+
+  /* server jupes */
+  jupe = ((ajupe = jupe_find(host)) && JupeIsActive(ajupe));
+
+  /* tell opers */
+  sendwallto_group_butone(&me, WALL_WALLOPS, 0,
+                          "Server test link from %s succes (crule: %s, juped: %s)",
+                          host,
+                          (crule != 0) ? "disallowed" : "allowed",
+                          jupe ? "yes" : "no");
+
+  /* tell other end and close connection */
+  return exit_client_msg(cptr, sptr, &me,
+                         "Server test link %s succes (crule: %s, juped: %s)",
+                         host,
+                         (crule != 0) ? "disallowed" : "allowed",
+                         jupe ? "yes" : "no");
+}
+
 /** Handle a SERVER message from an unregistered connection.
  *
  * \a parv has the following elements:
@@ -529,6 +602,10 @@
     return exit_client_msg(cptr, cptr, &me,
                            "Cannot connect a server to a user port");
 
+  /* test server link - snircd */
+  if ((parc > 1) && (parc < 8))
+    return test_server_link(cptr, sptr, parc, parv);
+
   if (parc < 8)
   {
     need_more_params(sptr, "SERVER");

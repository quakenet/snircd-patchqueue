add opkick command, similar to opmode command, but then for kicking
priv controlled by LOCAL_OPMODE and OPMODE
feature controlled by OPKICK (disabled by default), new p10 token OK
if implemented, it must not be enabled until ALL servers and services are upgraded
generates HACK(4) snomask notice for accountability with oper as source
probably needs some work (for one i simply copied the header from m_kick.c)

diff -r 8d3cf5a69cf8 include/handlers.h
--- a/include/handlers.h	Mon Jan 12 19:30:23 2009 +0100
+++ b/include/handlers.h	Mon Jan 12 20:26:49 2009 +0100
@@ -167,6 +167,7 @@
 extern int mo_kill(struct Client*, struct Client*, int, char*[]);
 extern int mo_notice(struct Client*, struct Client*, int, char*[]);
 extern int mo_oper(struct Client*, struct Client*, int, char*[]);
+extern int mo_opkick(struct Client*, struct Client*, int, char*[]);
 extern int mo_opmode(struct Client*, struct Client*, int, char*[]);
 extern int mo_ping(struct Client*, struct Client*, int, char*[]);
 extern int mo_privmsg(struct Client*, struct Client*, int, char*[]);
@@ -216,6 +217,7 @@
 extern int ms_nick(struct Client*, struct Client*, int, char*[]);
 extern int ms_notice(struct Client*, struct Client*, int, char*[]);
 extern int ms_oper(struct Client*, struct Client*, int, char*[]);
+extern int ms_opkick(struct Client*, struct Client*, int, char*[]);
 extern int ms_opmode(struct Client*, struct Client*, int, char*[]);
 extern int ms_part(struct Client*, struct Client*, int, char*[]);
 extern int ms_ping(struct Client*, struct Client*, int, char*[]);
diff -r 8d3cf5a69cf8 include/ircd_features.h
--- a/include/ircd_features.h	Mon Jan 12 19:30:23 2009 +0100
+++ b/include/ircd_features.h	Mon Jan 12 20:26:49 2009 +0100
@@ -105,6 +105,7 @@
   /* features that affect all operators */
   FEAT_EXTENDED_CHECKCMD,
   FEAT_CONFIG_OPERCMDS,
+  FEAT_OPKICK,
   FEAT_SETHOST,
   FEAT_SETHOST_USER,
   FEAT_SETHOST_AUTO,
diff -r 8d3cf5a69cf8 include/msg.h
--- a/include/msg.h	Mon Jan 12 19:30:23 2009 +0100
+++ b/include/msg.h	Mon Jan 12 20:26:49 2009 +0100
@@ -236,6 +236,10 @@
 #define TOK_KICK                "K"
 #define CMD_KICK		MSG_KICK, TOK_KICK
 
+#define MSG_OPKICK              "OPKICK"          /* OPKICK */
+#define TOK_OPKICK              "OK"
+#define CMD_OPKICK		MSG_OPKICK, TOK_OPKICK
+
 #define MSG_USERHOST            "USERHOST"      /* USER -> USRH */
 #define TOK_USERHOST            "USERHOST"
 #define CMD_USERHOST		MSG_USERHOST, TOK_USERHOST
diff -r 8d3cf5a69cf8 ircd/Makefile.in
--- a/ircd/Makefile.in	Mon Jan 12 19:30:23 2009 +0100
+++ b/ircd/Makefile.in	Mon Jan 12 20:26:49 2009 +0100
@@ -151,6 +151,7 @@
 	m_nick.c \
 	m_notice.c \
 	m_oper.c \
+	m_opkick.c \
 	m_opmode.c \
 	m_part.c \
 	m_pass.c \
@@ -884,6 +885,14 @@
   ../include/ircd_features.h ../include/s_conf.h ../include/client.h \
   ../include/s_debug.h ../include/s_user.h ../include/s_misc.h \
   ../include/send.h
+m_opkick.o: m_opkick.c ../config.h ../include/channel.h \
+  ../include/ircd_defs.h ../include/res.h ../config.h ../include/client.h \
+  ../include/dbuf.h ../include/msgq.h ../include/ircd_events.h \
+  ../include/ircd_handler.h ../include/capab.h ../include/hash.h \
+  ../include/ircd.h ../include/struct.h ../include/ircd_log.h \
+  ../include/ircd_reply.h ../include/ircd_string.h \
+  ../include/ircd_chattr.h ../include/msg.h ../include/numeric.h \
+  ../include/numnicks.h ../include/send.h ../include/ircd_features.h
 m_opmode.o: m_opmode.c ../config.h ../include/client.h \
   ../include/ircd_defs.h ../include/dbuf.h ../include/msgq.h \
   ../include/ircd_events.h ../config.h ../include/ircd_handler.h \
diff -r 8d3cf5a69cf8 ircd/ircd_features.c
--- a/ircd/ircd_features.c	Mon Jan 12 19:30:23 2009 +0100
+++ b/ircd/ircd_features.c	Mon Jan 12 20:26:49 2009 +0100
@@ -359,6 +359,7 @@
   /* features that affect all operators */
   F_B(EXTENDED_CHECKCMD, 0, 0, 0),
   F_B(CONFIG_OPERCMDS, 0, 0, 0),
+  F_B(OPKICK, 0, 0, 0),
   F_B(SETHOST, 0, 0, 0),
   F_B(SETHOST_USER, 0, 0, 0),
   F_B(SETHOST_AUTO, 0, 0, 0),
diff -r 8d3cf5a69cf8 ircd/m_opkick.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/ircd/m_opkick.c	Mon Jan 12 20:26:49 2009 +0100
@@ -0,0 +1,231 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_opkick.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+#include "config.h"
+
+#include "channel.h"
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "send.h"
+#include "ircd_features.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+
+/*
+ * mo_opkick - oper message handler
+ *
+ * parv[0] = sender prefix
+ * parv[1] = channel
+ * parv[2] = client to kick
+ * parv[parc-1] = kick comment
+ */
+int mo_opkick(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
+{
+  struct Client *who;
+  struct Channel *chptr;
+  struct Membership *member = 0;
+  struct Membership* member2;
+  char *name, *comment;
+
+  ClrFlag(sptr, FLAG_TS8);
+
+  if (!feature_bool(FEAT_OPKICK))
+    return send_reply(sptr, ERR_DISABLED, "OPKICK");
+
+  if (parc < 3 || *parv[1] == '\0')
+    return need_more_params(sptr, "OPKICK");
+
+  name = parv[1];
+
+  /* simple checks */
+  if (!(chptr = get_channel(sptr, name, CGT_NO_CREATE)))
+    return send_reply(sptr, ERR_NOSUCHCHANNEL, name);
+
+  if (!HasPriv(sptr, IsLocalChannel(chptr->chname) ? PRIV_LOCAL_OPMODE : PRIV_OPMODE))
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  if (!(who = find_chasing(sptr, parv[2], 0)))
+    return 0; /* find_chasing sends the reply for us */
+
+  /* Don't allow the channel service to be kicked */
+  if (IsChannelService(who)) {
+    if (IsService(cli_user(who)->server))
+      return send_reply(sptr, ERR_ISREALSERVICE, cli_name(who), chptr->chname);
+  }
+
+  /* check if kicked user is actually on the channel */
+  if (!(member = find_member_link(chptr, who)) || IsZombie(member))
+    return send_reply(sptr, ERR_USERNOTINCHANNEL, cli_name(who), chptr->chname);
+
+  /* We rely on ircd_snprintf to truncate the comment */
+  comment = EmptyString(parv[parc - 1]) ? parv[2] : parv[parc - 1];
+
+  if (!IsLocalChannel(name))
+    sendcmdto_serv_butone(sptr, CMD_OPKICK, cptr, "%H %C :%s", chptr, who, comment);
+
+  if (IsDelayedJoin(member)) {
+    /* If it's a delayed join, only send the KICK to the person doing
+     * the kicking and the victim */
+    if (MyUser(who))
+      sendcmdto_one(feature_bool(FEAT_HIS_MODEWHO) ? &his : sptr, CMD_KICK, who, "%H %C :%s", chptr, who, comment);
+    /* operator using OPKICK is on the channel */
+    if ((member2 = find_member_link(chptr, sptr)) && !IsZombie(member2)) {
+      sendcmdto_one(who, CMD_JOIN, sptr, "%H", chptr);
+      sendcmdto_one(feature_bool(FEAT_HIS_MODEWHO) ? &his : sptr, CMD_KICK, sptr, "%H %C :%s", chptr, who, comment);
+    }
+    CheckDelayedJoins(chptr);
+  } else
+    sendcmdto_channel_butserv_butone(feature_bool(FEAT_HIS_MODEWHO) ? &his : sptr,
+      CMD_KICK, chptr, NULL, 0, "%H %C :%s", chptr, who, comment);
+
+  /* Send HACK notice and log it */
+  sendto_opmask_butone(0, SNO_HACK4, "HACK(4): %C KICK %H %C %s", sptr, chptr, who, comment);
+  log_write(LS_OPERMODE, L_INFO, LOG_NOSNOTICE, "%#C OPKICK %H %C %s", sptr, chptr, who, comment);
+  
+  make_zombie(member, who, cptr, sptr, chptr);
+
+  return 0;
+}
+
+/*
+ * ms_opkick - server message handler
+ *
+ * parv[0] = sender prefix
+ * parv[1] = channel
+ * parv[2] = client to kick
+ * parv[parc-1] = kick comment
+ */
+int ms_opkick(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
+{
+  struct Client *who;
+  struct Channel *chptr;
+  struct Membership *member = 0, *sptr_link = 0;
+  char *name, *comment;
+
+  ClrFlag(sptr, FLAG_TS8);
+
+  if (parc < 3 || *parv[1] == '\0')
+    return need_more_params(sptr, "OPKICK");
+
+  name = parv[1];
+  comment = parv[parc - 1];
+
+  /* figure out who gets kicked from what */
+  if (IsLocalChannel(name) ||
+      !(chptr = get_channel(sptr, name, CGT_NO_CREATE)) ||
+      !(who = findNUser(parv[2])))
+    return 0;
+
+  /* We go ahead and pass on the KICK for users not on the channel */
+  if (!(member = find_member_link(chptr, who)) || IsZombie(member)) {
+    if (member) {
+      make_zombie(member, who, cptr, sptr, chptr);
+      member=0;
+    }
+  }
+
+  /* Propagate kick... */
+  sendcmdto_serv_butone(sptr, CMD_OPKICK, cptr, "%H %C :%s", chptr, who, comment);
+
+  if (member) { /* and tell the channel about it */
+    if (IsDelayedJoin(member)) {
+      if (MyUser(who))
+        sendcmdto_one((IsServer(sptr) || feature_bool(FEAT_HIS_MODEWHO)) ? &his : sptr,
+          CMD_KICK, who, "%H %C :%s", chptr, who, comment);
+    } else {
+      sendcmdto_channel_butserv_butone((IsServer(sptr) || feature_bool(FEAT_HIS_MODEWHO)) ? &his : sptr,
+        CMD_KICK, chptr, NULL, 0, "%H %C :%s", chptr, who, comment);
+    }
+
+    /* Send HACK notice and log it */
+    sendto_opmask_butone(0, SNO_HACK4, "HACK(4): %C KICK %H %C %s", sptr, chptr, who, comment);
+    log_write(LS_OPERMODE, L_INFO, LOG_NOSNOTICE, "%#C OPKICK %H %C %s", sptr, chptr, who, comment);
+      
+    make_zombie(member, who, cptr, sptr, chptr);
+  }
+  return 0;
+}
diff -r 8d3cf5a69cf8 ircd/parse.c
--- a/ircd/parse.c	Mon Jan 12 19:30:23 2009 +0100
+++ b/ircd/parse.c	Mon Jan 12 20:26:49 2009 +0100
@@ -656,6 +656,17 @@
     0, MAXPARA, MFLG_SLOW, 0, NULL,
     { m_unregistered, m_not_oper, m_check, m_check, m_ignore }
   },
+  
+  /*
+   * Add the command for OPKICK.
+   */
+  {
+    MSG_OPKICK,
+    TOK_OPKICK,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE */
+    { m_unregistered, m_not_oper, ms_opkick, mo_opkick, m_ignore }
+  },
 
   /* This command is an alias for QUIT during the unregistered part of
    * of the server.  This is because someone jumping via a broken web

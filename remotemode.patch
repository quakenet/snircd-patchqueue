# HG changeset patch
# Parent 1be233effe779b82ba5093211062fd9e13744463

# add REMOTEMODE (P10 token RM) allowing a service do change certain modes on users
#
# <source numeric server> RM <target numeric user> <mode> [<mode param1>] [<mode param2>] [<mode param3>] (note: no : prefixing last parameter)
#
# allow +-idwRnIxqQ
# allow +h <user@host> and -h (so we dont need remote sethost/SH token anymore), other modes are not allowed to be set remotely
#
# usermode i can only be unset if the user is +rx or +h - this prevents the user from becoming visiable with their realhost
# usermode x can only be set, not unset (same as normal)
# usermode h can only be unset, if the user is +rx (or +r and allowed to set +x) - this prevents exposing the realhost out of the blue
#
# easy to add/remove modes
#
# REMOTEMODE travels from source server to victim server, from where a normal usermode change is broadcasted to the network
#
# unfortunately the code is a bit messy because of the sethost stuff, should we in the future accept the sethost.patch (see queue), it can be cleaned up quite a bit
#
# part of the code is duplicate of the mode part in s_user.c for now, to avoid the chance of breaking things there

diff -r 1be233effe77 include/handlers.h
--- a/include/handlers.h
+++ b/include/handlers.h
@@ -224,6 +224,7 @@
 extern int ms_privmsg(struct Client*, struct Client*, int, char*[]);
 extern int ms_privs(struct Client*, struct Client*, int, char*[]);
 extern int ms_quit(struct Client*, struct Client*, int, char*[]);
+extern int ms_remotemode(struct Client*, struct Client*, int, char*[]);
 extern int ms_rping(struct Client*, struct Client*, int, char*[]);
 extern int ms_rpong(struct Client*, struct Client*, int, char*[]);
 extern int ms_server(struct Client*, struct Client*, int, char*[]);
diff -r 1be233effe77 include/msg.h
--- a/include/msg.h
+++ b/include/msg.h
@@ -363,6 +363,10 @@
 #define TOK_SETHOST		"SH"
 #define CMD_SETHOST		MSG_SETHOST, TOK_SETHOST
 
+#define MSG_REMOTEMODE            "REMOTEMODE"         /* REMOTEMODE */
+#define TOK_REMOTEMODE            "RM"
+#define CMD_REMOTEMODE            MSG_REMOTEMODE, TOK_REMOTEMODE
+
 #define MSG_CAP			"CAP"
 #define TOK_CAP			"CAP"
 #define CMD_CAP			MSG_CAP, TOK_CAP
diff -r 1be233effe77 ircd/Makefile.in
--- a/ircd/Makefile.in
+++ b/ircd/Makefile.in
@@ -162,6 +162,7 @@
 	m_pseudo.c \
 	m_quit.c \
 	m_rehash.c \
+	m_remotemode.c \
 	m_reset.c \
 	m_restart.c \
 	m_rping.c \
diff -r 1be233effe77 ircd/m_remotemode.c
--- /dev/null
+++ b/ircd/m_remotemode.c
@@ -0,0 +1,384 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_mode.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+
+#include "config.h"
+
+#include "channel.h"
+#include "client.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "ircd_snprintf.h"
+#include "msg.h"
+#include "msgq.h"
+#include "numeric.h"
+#include "querycmds.h"
+#include "s_conf.h"
+#include "s_debug.h"
+#include "s_user.h"
+#include "send.h"
+#include "struct.h"
+#include "numnicks.h"
+
+#include <stdlib.h>
+
+/**
+ * ms_remotemode - remotemode server message handler
+ *
+ * parv[0]  = sender prefix
+ * parv[1]  = target user numeric
+ * parv[2+] = mode and arguments
+ *
+ */
+int ms_remotemode(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target;
+  struct Client *acptr;
+  struct Flags setflags;
+  struct Membership *chan;
+
+  char** p;
+  char*  m;
+  char *hostmask;
+  char *user = NULL;
+  char *host = NULL;
+  char hiddenhost[USERLEN + HOSTLEN + 2];
+  int what = MODE_ADD;
+  int do_host_hiding = 0;
+  int do_set_host = 0;
+
+  /* not from a server */
+  if (!IsServer(sptr))
+    return protocol_violation(cptr, "Received REMOTEMODE from user %C", sptr);
+
+  /* check paramaters */
+  if (parc < 3)
+    return protocol_violation(cptr, "Received too few parameters for REMOTEMODE from %C (got %d - need at least 3)", parc, sptr);
+
+  /* check service */
+  if (!IsService(sptr))
+    return protocol_violation(sptr, "Received REMOTEMODE from %C but is not a service", sptr);
+
+  /* check Uworld block */
+  if (!find_conf_byhost(cli_confs(cptr), cli_name(sptr), CONF_UWORLD))
+    return protocol_violation(sptr, "Received REMOTEMODE from %C but has no Uworld block", sptr);
+
+  target = parv[1];
+
+  /* find user */
+  if (!(acptr = findNUser(target)))
+    return 0;
+
+  /* not for my user, pass it along */
+  if (!MyConnect(acptr)) {
+    sendcmdto_one(sptr, CMD_REMOTEMODE, acptr, "%C %s%s%s%s%s%s%s", acptr,
+      parv[2],
+      parc > 3 ? " " : "",
+      parc > 3 ? parv[3] : "",
+      parc > 4 ? " " : "",
+      parc > 4 ? parv[4] : "",
+      parc > 5 ? " " : "", 
+      parc > 5 ? parv[5] : "");
+    return 0;
+  }
+
+  /* backup flags */
+  setflags = cli_flags(acptr);
+
+  /* parse mode change string(s) */
+  for (p = &parv[2]; *p && p<&parv[parc]; p++) {  /* p is changed in loop too */
+    for (m = *p; *m; m++) {
+      switch (*m) {
+        case '+':
+          what = MODE_ADD;
+          break;
+        case '-':
+          what = MODE_DEL;
+          break;
+        case 'w':
+          if (what == MODE_ADD)
+            SetWallops(acptr);
+          else
+            ClearWallops(acptr);
+          break;
+        case 'i':
+          if (what == MODE_ADD)
+            SetInvisible(acptr);
+          else
+            ClearInvisible(acptr);
+          break;
+        case 'd':
+          if (what == MODE_ADD)
+            SetDeaf(acptr);
+          else
+            ClearDeaf(acptr);
+          break;
+        case 'n':
+          if (what == MODE_ADD)
+            SetNoChan(acptr);
+          else
+            ClearNoChan(acptr);
+          break;
+        case 'I':
+          if (what == MODE_ADD)
+            SetNoIdle(acptr);
+          else
+            ClearNoIdle(acptr);
+          break;
+        case 'R':
+          if (what == MODE_ADD)
+            SetAccountOnly(acptr);
+          else
+            ClearAccountOnly(acptr);
+          break;
+        case 'q':
+          if (what == MODE_ADD)
+            SetCommonChansOnly(acptr);
+          else
+            ClearCommonChansOnly(acptr);
+          break;
+        case 'Q':
+          if (what == MODE_ADD)
+            SetCommonChansOnlyRestricted(sptr);
+          else
+            ClearCommonChansOnlyRestricted(sptr);
+          break;
+        case 'x':
+          if (what == MODE_ADD)
+            do_host_hiding = 1;
+          break;
+        case 'h':
+          if (what == MODE_ADD) {
+            if (*(p + 1) && is_hostmask(*(p + 1))) {
+              do_set_host = 1;
+              hostmask = *++p;
+            } else {
+              if (!*(p+1))
+                protocol_violation(sptr, "Received REMOTEMODE +h for user %C but no host parameter", acptr);
+              else {
+                protocol_violation(sptr, "Received REMOTEMODE +h for user %C but invalid host parameter %s", acptr, *(p+1));
+                p++; /* Swallow the arg anyway */
+              }
+            }
+          } else { /* MODE_DEL */
+            do_set_host = 1;
+            hostmask = NULL;
+          }
+          break;
+
+        default:
+          /*
+           * unknown or disallowed mode for remote mode
+           * do not bother with an error reply or protocol violation
+           * the service should know valid modes for remote mode
+           */
+          break;
+      }
+    }
+  }
+
+  /* do host hiding for +x */
+  if (!FlagHas(&setflags, FLAG_HIDDENHOST) && do_host_hiding)
+    hide_hostmask(acptr, FLAG_HIDDENHOST);
+
+  /* sanity checks for -h */
+  if (do_set_host && !hostmask) {
+
+    /* no sethost */
+    if (!IsSetHost(acptr))
+      do_set_host = 0;
+
+    /* no account
+     *
+     * user has +h - their host is hidden, do not remove it
+     *   unless the user has an account set
+     *     we should not out of the blue expose the real host
+     */
+    else if (!IsAccount(acptr))
+      do_set_host = 0;
+
+    /* user not +x and not allowed to set it */
+    else if (!IsHiddenHost(acptr) && !feature_bool(FEAT_HOST_HIDING))
+      do_set_host = 0;
+
+    /* set +x */
+    else 
+      SetHiddenHost(acptr);
+  }
+
+  /* sanity checks for +h */
+  if (do_set_host && hostmask) {
+    if ((host = strrchr(hostmask, '@'))) {
+      *host++ = '\0';
+      user = hostmask;
+    }
+    else
+      host = hostmask;
+
+    /* check if new sethost is different from before */
+    if (IsSetHost(acptr) && 
+       (!user || strcmp(cli_user(acptr)->username, user) == 0) &&
+        strcmp(cli_user(acptr)->host, host) == 0)
+      do_set_host = 0;
+  }
+
+  /* do host hiding for +h/-h */
+  if (do_set_host) {
+
+    /* quit user from channel */
+    sendcmdto_common_channels_butone(acptr, CMD_QUIT, acptr, ":Host change");
+
+    /* set +h */
+    if (host) {
+      SetSetHost(acptr);
+      /* clear +h in old flags so +h is sent out again with new sethost param */
+      FlagClr(&setflags, FLAG_SETHOST);
+      if (user)
+        ircd_strncpy(cli_user(acptr)->username, user, USERLEN);
+      ircd_strncpy(cli_user(acptr)->host, host, HOSTLEN);
+
+    /* set -h */
+    } else {
+      ClearSetHost(acptr);
+      ircd_strncpy(cli_user(acptr)->username, cli_user(acptr)->realusername, USERLEN);
+      /* user is +rx - need to restore +x host */
+      if (HasHiddenHost(acptr)) 
+        ircd_snprintf(0, cli_user(acptr)->host, HOSTLEN, "%s.%s",
+          cli_user(acptr)->account, feature_str(FEAT_HIDDEN_HOST));
+      else
+        ircd_strncpy(cli_user(acptr)->host, cli_user(acptr)->realhost, HOSTLEN);
+    }
+
+    /* inform user of hidden host */
+    ircd_snprintf(0, hiddenhost, HOSTLEN + USERLEN + 2, "%s@%s",
+      cli_user(acptr)->username, cli_user(acptr)->host);
+    send_reply(acptr, RPL_HOSTHIDDEN, hiddenhost);
+
+    /*
+     * Go through all channels the client was on, rejoin him
+     * and set the modes, if any
+     */
+    for (chan = cli_user(acptr)->channel; chan; chan = chan->next_channel) {
+      /* Invalidate bans against the user so we check them again */
+      ClearBanValid(chan);
+      if (IsZombie(chan))
+        continue;
+      /* If this channel has delayed joins and the user has no modes, just set
+       * the delayed join flag rather than showing the join, even if the user
+       * was visible before */
+      if (!IsChanOp(chan) && !HasVoice(chan)
+          && (chan->channel->mode.mode & MODE_DELJOINS)) {
+        SetDelayedJoin(chan);
+      } else {
+        sendcmdto_channel_butserv_butone(acptr, CMD_JOIN, chan->channel, acptr, 0,
+          "%H", chan->channel);
+      }
+      if (IsChanOp(chan) && HasVoice(chan)) {
+        sendcmdto_channel_butserv_butone(&his, CMD_MODE, chan->channel, acptr, 0,
+          "%H +ov %C %C", chan->channel, acptr, acptr);
+      } else if (IsChanOp(chan) || HasVoice(chan)) {
+        sendcmdto_channel_butserv_butone(&his, CMD_MODE, chan->channel, acptr, 0,
+          "%H +%c %C", chan->channel, IsChanOp(chan) ? 'o' : 'v', acptr);
+      }
+    }
+  }
+
+  /* do not set a user -i when they do not have a hiddenhost or sethost */
+  if (FlagHas(&setflags, FLAG_INVISIBLE) && !IsInvisible(acptr) && !HasHiddenHost(acptr) && !IsSetHost(acptr))
+    SetInvisible(acptr);
+
+  /* adjust count for invisible/visible users */
+  if (FlagHas(&setflags, FLAG_INVISIBLE) && !IsInvisible(acptr)) {
+    assert(UserStats.inv_clients > 0);
+    --UserStats.inv_clients;
+  }
+  if (!FlagHas(&setflags, FLAG_INVISIBLE) && IsInvisible(acptr)) {
+    ++UserStats.inv_clients;
+  }
+  assert(UserStats.inv_clients <= UserStats.clients + UserStats.unknowns);
+
+  /* send out the mode */
+  send_umode_out(acptr, acptr, &setflags, 0);
+
+  return 0;
+}
diff -r 1be233effe77 ircd/parse.c
--- a/ircd/parse.c
+++ b/ircd/parse.c
@@ -541,6 +541,13 @@
     { m_ignore, m_ignore, ms_end_of_burst_ack, m_ignore, m_ignore }
   },
   {
+    MSG_REMOTEMODE,
+    TOK_REMOTEMODE,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE */
+    { m_ignore, m_ignore, ms_remotemode, m_ignore, m_ignore }
+  },
+  {
     MSG_HASH,
     TOK_HASH,
     0, MAXPARA, MFLG_SLOW, 0, NULL,
diff -r 1be233effe77 ircd/s_user.c
--- a/ircd/s_user.c
+++ b/ircd/s_user.c
@@ -1227,6 +1227,10 @@
  *                        only permitting legitimate default user modes.
  * @return Zero.
  */
+/* When adding or changing modes, do not forget REMOTEMODE,
+ * it has its own mode handling function in m_remotemode.c
+ * for the time being - snircd
+ */
 int set_user_mode(struct Client *cptr, struct Client *sptr, int parc, 
 		char *parv[], int allow_modes)
 {
@@ -1281,6 +1285,7 @@
   /*
    * parse mode change string(s)
    */
+  /* remotemode has its own mode handling function in m_remotemode.c - snircd */
   for (p = &parv[2]; *p && p<&parv[parc]; p++) {       /* p is changed in loop too */
     for (m = *p; *m; m++) {
       switch (*m) {

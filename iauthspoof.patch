# HG changeset patch
# Parent bf5c933d38153082b961a0cb7b4be88ee6622fe7

diff -r bf5c933d3815 doc/readme.iauth
--- a/doc/readme.iauth	Sat Jul 20 09:24:13 2013 +0200
+++ b/doc/readme.iauth	Sat Jul 20 09:27:32 2013 +0200
@@ -488,3 +488,10 @@
   sent to <servername>.
 Compatibility: This is an Undernet extension and ircd does not support
   this message.
+
+H - Set Host
+Syntax: H <id> <remoteip> <remoteport> <username> <hostname>
+Example: H 5 192.168.1.10 23367 webchat example.host
+Comments: Used by the iauth instance to set a user's spoof host.
+Compatibility: This is an Undernet extension and ircd does not support
+  this message.
diff -r bf5c933d3815 ircd/s_auth.c
--- a/ircd/s_auth.c	Sat Jul 20 09:24:13 2013 +0200
+++ b/ircd/s_auth.c	Sat Jul 20 09:27:32 2013 +0200
@@ -103,6 +103,8 @@
   struct AuthRequestFlags flags;  /**< current state of request */
   unsigned int        cookie;     /**< cookie the user must PONG */
   unsigned short      port;       /**< client's remote port number */
+  char                spoofuser[USERLEN+1]; /**< spoofed username */
+  char                spoofhost[HOSTLEN+1]; /**< spoofed hostname */
 };
 
 /** Array of message text (with length) pairs for AUTH status
@@ -328,6 +330,40 @@
   return exit_client(sptr, sptr, &me, "USER: Bad username");
 }
 
+/** Set spoofed username/hostname for user associated with \a auth.
+ * @param[in] auth Client authorization request to work on.
+ * @return Zero if client is kept, CPTR_KILLED if client rejected.
+ */
+static int auth_set_spoof(struct AuthRequest *auth)
+{
+  struct Client *sptr = auth->client;
+
+  if (!EmptyString(auth->spoofuser) && !EmptyString(auth->spoofhost)) {
+    SetSetHost(sptr);
+    ircd_strncpy(cli_user(sptr)->username, auth->spoofuser, USERLEN);
+    ircd_strncpy(cli_user(sptr)->host, auth->spoofhost, HOSTLEN);
+  }
+
+  return 0;
+}
+
+/** Inform a client that they have a spoofed username/hostname.
+ * @param[in] auth Client authorization request to work on.
+ * @return Zero if client is kept, CPTR_KILLED if client rejected.
+ */
+static int auth_inform_spoof(struct AuthRequest *auth)
+{
+  struct Client *sptr = auth->client;
+  char hostmask[USERLEN + HOSTLEN + 2];
+
+  if (!EmptyString(auth->spoofuser) && !EmptyString(auth->spoofhost)) {
+    ircd_snprintf(0, hostmask, USERLEN + HOSTLEN + 2, "%s@%s", auth->spoofuser, auth->spoofhost);
+    send_reply(sptr, RPL_HOSTHIDDEN, hostmask);
+  }
+
+  return 0;
+}
+
 /** Check whether an authorization request is complete.
  * This means that no flags from 0 to #AR_LAST_SCAN are set on \a auth.
  * If #AR_IAUTH_PENDING is set, optionally go into "hurry" state.  If
@@ -408,7 +444,11 @@
     memset(cli_passwd(auth->client), 0, sizeof(cli_passwd(auth->client)));
     res = auth_set_username(auth);
     if (res == 0)
+      res = auth_set_spoof(auth);
+    if (res == 0)
       res = register_user(auth->client, auth->client);
+    if (res == 0)
+      res = auth_inform_spoof(auth);
   }
   else
     res = 0;
@@ -2014,6 +2054,22 @@
   return 0;
 }
 
+/** Sets spoof username/host for a client.
+ * @param[in] cli Client referenced by command.
+ * @param[in] parc Number of parameters (at least one).
+ * @param[in] params The spoof username and hostname.
+ * @return Zero.
+ */
+static int iauth_cmd_spoof(struct IAuth *iauth, struct Client *cli,
+                              int parc, char **params)
+{
+  if (parc >= 2) {
+    ircd_strncpy(cli_auth(cli)->spoofuser, params[0], USERLEN);
+    ircd_strncpy(cli_auth(cli)->spoofhost, params[1], HOSTLEN);
+  }
+
+  return 0;
+}
 
 /** Send a challenge string to the client.
  * @param[in] iauth Active IAuth session.
@@ -2110,6 +2166,7 @@
   case 'N': handler = iauth_cmd_hostname; has_cli = 1; break;
   case 'I': handler = iauth_cmd_ip_address; has_cli = 1; break;
   case 'M': handler = iauth_cmd_usermode; has_cli = 1; break;
+  case 'H': handler = iauth_cmd_spoof; has_cli = 1; break;
   case 'C': handler = iauth_cmd_challenge; has_cli = 1; break;
   case 'd': handler = iauth_cmd_soft_done; has_cli = 1; break;
   case 'D': handler = iauth_cmd_done_client; has_cli = 1; break;

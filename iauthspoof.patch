# HG changeset patch
# Parent 53acaad82d2b53a0ce91750056c5a3e378c0050d

diff -r 53acaad82d2b ircd/s_auth.c
--- a/ircd/s_auth.c	Mon Jul 08 09:08:29 2013 +0200
+++ b/ircd/s_auth.c	Mon Jul 08 12:35:53 2013 +0200
@@ -102,6 +102,8 @@
   struct AuthRequestFlags flags;  /**< current state of request */
   unsigned int        cookie;     /**< cookie the user must PONG */
   unsigned short      port;       /**< client's remote port number */
+  char                spoofuser[USERLEN+1]; /**< spoofed username */
+  char                spoofhost[HOSTLEN+1]; /**< spoofed hostname */
 };
 
 /** Array of message text (with length) pairs for AUTH status
@@ -327,6 +329,40 @@
   return exit_client(sptr, sptr, &me, "USER: Bad username");
 }
 
+/** Set spoofed username/hostname for user associated with \a auth.
+ * @param[in] auth Client authorization request to work on.
+ * @return Zero if client is kept, CPTR_KILLED if client rejected.
+ */
+static int auth_set_spoof(struct AuthRequest *auth)
+{
+  struct Client *sptr = auth->client;
+
+  if (!EmptyString(auth->spoofuser) && !EmptyString(auth->spoofhost)) {
+    SetSetHost(sptr);
+    ircd_strncpy(cli_user(sptr)->username, auth->spoofuser, USERLEN);
+    ircd_strncpy(cli_user(sptr)->host, auth->spoofhost, HOSTLEN);
+  }
+
+  return 0;
+}
+
+/** Inform a client that they have a spoofed username/hostname.
+ * @param[in] auth Client authorization request to work on.
+ * @return Zero if client is kept, CPTR_KILLED if client rejected.
+ */
+static int auth_inform_spoof(struct AuthRequest *auth)
+{
+  struct Client *sptr = auth->client;
+  char hostmask[USERLEN + HOSTLEN + 2];
+
+  if (!EmptyString(auth->spoofuser) && !EmptyString(auth->spoofhost)) {
+    ircd_snprintf(0, hostmask, USERLEN + HOSTLEN + 2, "%s@%s", auth->spoofuser, auth->spoofhost);
+    send_reply(sptr, RPL_HOSTHIDDEN, hostmask);
+  }
+
+  return 0;
+}
+
 /** Check whether an authorization request is complete.
  * This means that no flags from 0 to #AR_LAST_SCAN are set on \a auth.
  * If #AR_IAUTH_PENDING is set, optionally go into "hurry" state.  If
@@ -407,7 +443,11 @@
     memset(cli_passwd(auth->client), 0, sizeof(cli_passwd(auth->client)));
     res = auth_set_username(auth);
     if (res == 0)
+      res = auth_set_spoof(auth);
+    if (res == 0)
       res = register_user(auth->client, auth->client);
+    if (res == 0)
+      res = auth_inform_spoof(auth);
   }
   else
     res = 0;
@@ -1996,6 +2036,22 @@
   return 0;
 }
 
+/** Sets spoof username/host for a client.
+ * @param[in] cli Client referenced by command.
+ * @param[in] parc Number of parameters (at least one).
+ * @param[in] params The spoof username and hostname.
+ * @return Zero.
+ */
+static int iauth_cmd_spoof(struct IAuth *iauth, struct Client *cli,
+                              int parc, char **params)
+{
+  if (parc >= 2) {
+    ircd_strncpy(cli_auth(cli)->spoofuser, params[0], USERLEN);
+    ircd_strncpy(cli_auth(cli)->spoofhost, params[1], HOSTLEN);
+  }
+
+  return 0;
+}
 
 /** Send a challenge string to the client.
  * @param[in] iauth Active IAuth session.
@@ -2092,6 +2148,7 @@
   case 'N': handler = iauth_cmd_hostname; has_cli = 1; break;
   case 'I': handler = iauth_cmd_ip_address; has_cli = 1; break;
   case 'M': handler = iauth_cmd_usermode; has_cli = 1; break;
+  case 'H': handler = iauth_cmd_spoof; has_cli = 1; break;
   case 'C': handler = iauth_cmd_challenge; has_cli = 1; break;
   case 'D': handler = iauth_cmd_done_client; has_cli = 1; break;
   case 'R': handler = iauth_cmd_done_account; has_cli = 1; break;

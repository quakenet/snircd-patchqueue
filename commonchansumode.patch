Add usermode +q which requires users /msg'ing or /notice'ing you to be in at least one common channel.
This is designed to stop the spam bots which sit outside a channel, while a spy sits inside, preventing channel operators dealing with the problem.
We currently also block invites, this might not be such a good idea, but these days everyone can get Q.

diff -r f0443c491386 include/channel.h
--- a/include/channel.h	Sat Jul 20 16:28:42 2013 +0200
+++ b/include/channel.h	Sat Jul 20 16:29:41 2013 +0200
@@ -280,6 +280,7 @@
   struct SLink*      invites;	   /**< List of invites on this channel */
   struct Ban*        banlist;      /**< List of bans on this channel */
   struct Mode        mode;	   /**< This channels mode */
+  unsigned int       marker;       /**< Channel marker */
   char               topic[TOPICLEN + 1]; /**< Channels topic */
   char               topic_nick[NICKLEN + 1]; /**< Nick of the person who set
 						*  The topic
@@ -457,4 +458,8 @@
 extern int apply_ban(struct Ban **banlist, struct Ban *newban, int free);
 extern void free_ban(struct Ban *ban);
 
+extern int common_chan_count(struct Client *a, struct Client *b, int max);
+
+extern unsigned int get_channel_marker(void);
+
 #endif /* INCLUDED_channel_h */
diff -r f0443c491386 include/client.h
--- a/include/client.h	Sat Jul 20 16:28:42 2013 +0200
+++ b/include/client.h	Sat Jul 20 16:29:41 2013 +0200
@@ -90,7 +90,7 @@
 #define FlagClr(set,flag) ((set)->bits[FLAGSET_INDEX(flag)] &= ~FLAGSET_MASK(flag))
 
 /** String containing valid user modes, in no particular order. */
-#define infousermodes "dioswkgxRXInP"
+#define infousermodes "dioswkgxRXInPq"
 
 /** Character to indicate no oper name available */
 #define NOOPERNAMECHARACTER '-'
@@ -184,6 +184,8 @@
     FLAG_NOCHAN,                    /**< user's channels are hidden */
     FLAG_NOIDLE,                    /**< user's idletime is hidden */
     FLAG_XTRAOP,                    /**< oper has special powers */
+    FLAG_COMMONCHANSONLY,           /**< SNIRCD_q: hide privmsgs/notices if in no
+					 common channels (with +ok exceptions) */
 
     FLAG_LAST_FLAG,                 /**< number of flags */
     FLAG_LOCAL_UMODES = FLAG_LOCOP, /**< First local mode flag */
@@ -269,7 +271,7 @@
                                      server, XXX if this is a user */
   time_t         cli_firsttime;   /**< time client was created */
   time_t         cli_lastnick;    /**< TimeStamp on nick */
-  int            cli_marker;      /**< /who processing marker */
+  unsigned int   cli_marker;      /**< processing marker */
   struct Flags   cli_flags;       /**< client flags */
   unsigned int   cli_hopcount;    /**< number of servers to this 0 = local */
   struct irc_in_addr cli_ip;      /**< Real IP of client */
@@ -616,6 +618,8 @@
 #define IsParanoid(x)           HasFlag(x, FLAG_PARANOID)
 /** Return non-zero if the server should send opername information */
 #define IsSendOperName(x)         HasFlag(x, FLAG_OPERNAME)
+/** Return non-zero if the client has set mode +q (common chans only). */
+#define IsCommonChansOnly(x)    HasFlag(x, FLAG_COMMONCHANSONLY)
 
 /** Return non-zero if the client has operator or server privileges. */
 #define IsPrivileged(x)         (IsAnOper(x) || IsServer(x))
@@ -681,6 +685,8 @@
 #define SetAccountOnly(x)       SetFlag(x, FLAG_ACCOUNTONLY)
 /** Mark a client as having mode +P (paranoid). */
 #define SetParanoid(x)          SetFlag(x, FLAG_PARANOID)
+/** Mark a client as having mode +q (common chans only). */
+#define SetCommonChansOnly(x)   SetFlag(x, FLAG_COMMONCHANSONLY)
 
 /** Return non-zero if \a sptr sees \a acptr as an operator. */
 #define SeeOper(sptr,acptr) (IsAnOper(acptr) && (HasPriv(acptr, PRIV_DISPLAY) \
@@ -728,6 +734,8 @@
 #define ClearAccountOnly(x)     ClrFlag(x, FLAG_ACCOUNTONLY)
 /** Remove mode +P (paranoid) from a client */
 #define ClearParanoid(x)        ClrFlag(x, FLAG_PARANOID)
+/** Remove mode +q (common chans only) from a client */
+#define ClearCommonChansOnly(x) ClrFlag(x, FLAG_COMMONCHANSONLY)
 
 /* free flags */
 #define FREEFLAG_SOCKET	0x0001	/**< socket needs to be freed */
@@ -801,6 +809,7 @@
 			     struct Connection** con_p);
 extern void client_set_privs(struct Client *client, struct ConfItem *oper);
 extern int client_report_privs(struct Client* to, struct Client* client);
+extern unsigned int get_client_marker(void);
 
 #endif /* INCLUDED_client_h */
 
diff -r f0443c491386 include/numeric.h
--- a/include/numeric.h	Sat Jul 20 16:28:42 2013 +0200
+++ b/include/numeric.h	Sat Jul 20 16:29:41 2013 +0200
@@ -420,6 +420,7 @@
 /*	ERR_HTMDISABLED      486	   unreal */
 #define ERR_ACCOUNTONLY      486	/* QuakeNet/ASUKA extension */
 /*      ERR_CHANTOORECENT    487           IRCnet extension (?) */
+#define ERR_COMMONCHANSONLY  487        /* QuakeNet/snircd extension */
 /*      ERR_TSLESSCHAN       488           IRCnet extension (?) */
 #define ERR_VOICENEEDED      489        /* Undernet extension */
 
diff -r f0443c491386 ircd/channel.c
--- a/ircd/channel.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/channel.c	Sat Jul 20 16:29:41 2013 +0200
@@ -3850,3 +3850,65 @@
                                      "%H -d", chan);
   }
 }
+
+/* Returns the number of common channels between two users, upto max. */
+int common_chan_count(struct Client *a, struct Client *b, int max)
+{
+  int count = 0;
+  struct Membership *cptr;
+  struct User *ua, *ub;
+  unsigned int marker;
+
+  ua = cli_user(a);
+  ub = cli_user(b);
+
+  /* no channels, no need to check */
+  if ((ua->joined == 0) || (ub->joined == 0))
+  {
+    return 0;
+  }
+
+  marker = get_channel_marker();
+
+  /* makes no difference to the big O complexity I know */
+  if (ua->joined > ub->joined)
+  {
+    struct User *swapee = ua;
+    ua = ub;
+    ub = swapee;
+  }
+
+  for (cptr=ua->channel;cptr;cptr=cptr->next_channel)
+  {
+    cptr->channel->marker = marker;
+  }
+
+  for (cptr=ub->channel;cptr;cptr=cptr->next_channel)
+  {
+    if (cptr->channel->marker == marker) {
+      count++;
+      if (max && (count >= max))
+        return count;
+    }
+  }
+
+  return count;
+}
+
+unsigned int get_channel_marker(void)
+{
+  static unsigned int marker = 0;
+
+  if (!++marker)
+  {
+    struct Channel *cptr;
+    for (cptr=GlobalChannelList;cptr;cptr=cptr->next)
+    {
+      cptr->marker = 0;
+    }
+
+    marker++;
+  }
+
+  return marker;
+}
diff -r f0443c491386 ircd/client.c
--- a/ircd/client.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/client.c	Sat Jul 20 16:29:41 2013 +0200
@@ -266,3 +266,24 @@
 
   return 0;
 }
+
+/*
+ * A little spin-marking utility to tell us which clients we have already
+ * processed and which not
+ */
+unsigned int get_client_marker(void)
+{
+  static unsigned int marker = 0;
+
+  if (!++marker)
+  {
+    struct Client *cptr;
+    for (cptr=GlobalClientList;cptr;cptr=cli_next(cptr))
+    {
+      cli_marker(cptr) = 0;
+    }
+    marker++;
+  }
+
+  return marker;
+}
diff -r f0443c491386 ircd/ircd_relay.c
--- a/ircd/ircd_relay.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/ircd_relay.c	Sat Jul 20 16:29:41 2013 +0200
@@ -304,6 +304,10 @@
   if (host)
     *--host = '%';
 
+  /* slug: same applies here, since only opers can be +k */
+  if (IsCommonChansOnly(acptr) && !IsXtraOp(sptr) && !common_chan_count(acptr, sptr, 1))
+    return;
+
   if (!(is_silenced(sptr, acptr)))
     sendcmdto_one(sptr, CMD_PRIVATE, acptr, "%s :%s", name, text);
 }
@@ -353,6 +357,9 @@
   if (host)
     *--host = '%';
 
+  if (IsCommonChansOnly(acptr) && !IsXtraOp(sptr) && !common_chan_count(acptr, sptr, 1))
+    return;
+
   if (!(is_silenced(sptr, acptr)))
     sendcmdto_one(sptr, CMD_NOTICE, acptr, "%s :%s", name, text);
 }
@@ -392,6 +399,11 @@
     return;
   }
 
+  if (IsCommonChansOnly(acptr) && !IsXtraOp(sptr) && !common_chan_count(acptr, sptr, 1)) {
+    send_reply(sptr, ERR_COMMONCHANSONLY, cli_name(acptr));
+    return;
+  }
+
   /*
    * send away message if user away
    */
@@ -436,6 +448,9 @@
   if (IsAccountOnly(acptr) && !IsAccount(sptr) && !IsOper(sptr))
     return;
 
+  if (IsCommonChansOnly(acptr) && !IsXtraOp(sptr) && !common_chan_count(acptr, sptr, 1))
+    return;
+
   /*
    * deliver the message
    */
diff -r f0443c491386 ircd/m_invite.c
--- a/ircd/m_invite.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/m_invite.c	Sat Jul 20 16:29:41 2013 +0200
@@ -171,6 +171,11 @@
     return 0;
   }
   
+  if (IsCommonChansOnly(acptr) && !IsXtraOp(sptr) && !common_chan_count(acptr, sptr, 1)) {
+    send_reply(sptr, ERR_COMMONCHANSONLY, cli_name(acptr));
+    return 0;
+  }
+
   if (check_target_limit(sptr, acptr, cli_name(acptr), 0))
     return 0;
 
diff -r f0443c491386 ircd/m_who.c
--- a/ircd/m_who.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/m_who.c	Sat Jul 20 16:29:41 2013 +0200
@@ -99,26 +99,6 @@
 /* #include <assert.h> -- Now using assert in ircd_log.h */
 #include <string.h>
 
-
-/*
- * A little spin-marking utility to tell us which clients we have already
- * processed and which not
- */
-static int who_marker = 0;
-static void move_marker(void)
-{
-  if (!++who_marker)
-  {
-    struct Client *cptr = GlobalClientList;
-    while (cptr)
-    {
-      cli_marker(cptr) = 0;
-      cptr = cli_next(cptr);
-    }
-    who_marker++;
-  }
-}
-
 #define CheckMark(x, y) ((x == y) ? 0 : (x = y))
 #define Process(cptr) CheckMark(cli_marker(cptr), who_marker)
 
@@ -155,6 +135,7 @@
   char *p;                      /* Scratch char pointer                     */
   char *qrt;                    /* Pointer to the query type                */
   static char mymask[512];      /* To save the mask before corrupting it    */
+  unsigned int who_marker;      /* Used to mark clients we've touched       */
 
   /* Let's find where is our mask, and if actually contains something */
   mask = ((parc > 1) ? parv[1] : 0);
@@ -312,7 +293,7 @@
   counter = (2048 / (counter + 4));
   if (mask && (strlen(mask) > 510))
     mask[510] = '\0';
-  move_marker();
+  who_marker = get_client_marker();
   commas = (mask && strchr(mask, ','));
 
   /* First treat mask as a list of plain nicks/channels */
diff -r f0443c491386 ircd/s_err.c
--- a/ircd/s_err.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/s_err.c	Sat Jul 20 16:29:41 2013 +0200
@@ -1006,7 +1006,7 @@
 /* 486 */
   { ERR_ACCOUNTONLY, "%s :You must be authed in order to message this user -- For details of how to obtain an account visit %s", "486" },
 /* 487 */
-  { 0 },
+  { ERR_COMMONCHANSONLY, "%s :You must share at least one channel with this user in order to message them", "487" },
 /* 488 */
   { 0 },
 /* 489 */
diff -r f0443c491386 ircd/s_user.c
--- a/ircd/s_user.c	Sat Jul 20 16:28:42 2013 +0200
+++ b/ircd/s_user.c	Sat Jul 20 16:29:41 2013 +0200
@@ -552,7 +552,8 @@
   { FLAG_NOCHAN,      'n' },
   { FLAG_NOIDLE,      'I' },
   { FLAG_SETHOST,     'h' },
-  { FLAG_PARANOID,    'P' }
+  { FLAG_PARANOID,    'P' },
+  { FLAG_COMMONCHANSONLY, 'q' }
 };
 
 /** Length of #userModeList. */
@@ -863,7 +864,9 @@
       send_reply(source, ERR_ACCOUNTONLY, cli_name(dest), feature_str(FEAT_URLREG));
     return 0;
   }
-          
+
+  /* No check here for IsCommonChansOnly since by definition we share at least one! */
+
   if (is_notice)
     sendcmdto_one(source, CMD_NOTICE, dest, "%C :%s", dest, text);
   else
@@ -1436,6 +1439,12 @@
         else
           ClearParanoid(sptr);
 	break;
+      case 'q':
+	if (what == MODE_ADD)
+          SetCommonChansOnly(sptr);
+        else
+          ClearCommonChansOnly(sptr);
+	break;
       case 'r':
 	if ((what == MODE_ADD) && *(p + 1)) {
 	  account = *(++p);

# HG changeset patch
# Parent f8dc614ddef650bc216cd8475b5add79ab2259aa

Simulate a server connection, to verify a real server connection can be made, without affecting existing server links.

Patch by thommey and wiebe

diff -r f8dc614ddef6 include/client.h
--- a/include/client.h
+++ b/include/client.h
@@ -152,6 +152,7 @@
     FLAG_BLOCKED,                   /**< socket is in a blocked condition */
     FLAG_CLOSING,                   /**< set when closing to suppress errors */
     FLAG_UPING,                     /**< has active UDP ping request */
+    FLAG_SIMULATE,                  /**< simulating server connection */
     FLAG_HUB,                       /**< server is a hub */
     FLAG_IPV6,                      /**< server understands P10 IPv6 addrs */
     FLAG_SERVICE,                   /**< server is a service */
@@ -579,6 +580,8 @@
 #define IsOper(x)               HasFlag(x, FLAG_OPER)
 /** Return non-zero if the client has an active UDP ping request. */
 #define IsUPing(x)              HasFlag(x, FLAG_UPING)
+/** Return non-zero if the client. */
+#define IsSimulate(x)              HasFlag(x, FLAG_SIMULATE)
 /** Return non-zero if the client has no '\n' in its buffer. */
 #define NoNewLine(x)            HasFlag(x, FLAG_NONL)
 /** Return non-zero if the client has set mode +g (debugging). */
@@ -646,6 +649,8 @@
 #define SetOper(x)              SetFlag(x, FLAG_OPER)
 /** Mark a client as having a pending UDP ping. */
 #define SetUPing(x)             SetFlag(x, FLAG_UPING)
+/** Mark a client as having a simulated server link. */
+#define SetSimulate(x)          SetFlag(x, FLAG_SIMULATE)
 /** Mark a client as having mode +w (wallops). */
 #define SetWallops(x)           SetFlag(x, FLAG_WALLOP)
 /** Mark a client as having mode +s (server notices). */
@@ -701,6 +706,8 @@
 #define ClearOper(x)            ClrFlag(x, FLAG_OPER)
 /** Clear the client's pending UDP ping flag. */
 #define ClearUPing(x)           ClrFlag(x, FLAG_UPING)
+/** Clear the client's flag. */
+#define ClearSimulate(x)        ClrFlag(x, FLAG_SIMULATE)
 /** Remove mode +w (wallops) from the client. */
 #define ClearWallops(x)         ClrFlag(x, FLAG_WALLOP)
 /** Remove mode +s (server notices) from the client. */
diff -r f8dc614ddef6 include/s_bsd.h
--- a/include/s_bsd.h
+++ b/include/s_bsd.h
@@ -60,7 +60,7 @@
  * Proto types
  */
 extern unsigned int deliver_it(struct Client *cptr, struct MsgQ *buf);
-extern int connect_server(struct ConfItem* aconf, struct Client* by);
+extern int connect_server(struct ConfItem* aconf, struct Client* by, int simulate);
 extern int  net_close_unregistered_connections(struct Client* source);
 extern void close_connection(struct Client *cptr);
 extern void add_connection(struct Listener* listener, int fd);
diff -r f8dc614ddef6 include/s_conf.h
--- a/include/s_conf.h
+++ b/include/s_conf.h
@@ -65,6 +65,7 @@
   time_t hold;        /**< Earliest time to attempt an outbound
                          connect on this ConfItem. */
   int dns_pending;    /**< A dns request is pending. */
+  int dns_simulate;   /**< DNS request was sent for connection simulation. */
   int flags;          /**< Additional modifiers for item. */
   int addrbits;       /**< Number of bits valid in ConfItem::address. */
   struct Privs privs; /**< Privileges for opers. */
diff -r f8dc614ddef6 ircd/ircd.c
--- a/ircd/ircd.c
+++ b/ircd/ircd.c
@@ -304,7 +304,7 @@
     }
 
     /* Activate the connection itself. */
-    if (connect_server(aconf, 0))
+    if (connect_server(aconf, 0, 0))
       sendto_opmask_butone(0, SNO_OLDSNO, "Connection to %s activated.",
 			   aconf->name);
 
diff -r f8dc614ddef6 ircd/m_connect.c
--- a/ircd/m_connect.c
+++ b/ircd/m_connect.c
@@ -119,6 +119,7 @@
   struct ConfItem* aconf;
   struct Client*   acptr;
   struct Jupe*     ajupe;
+  int              simulate = 0;  /* simulate connection */
 
   assert(0 != cptr);
   assert(0 != sptr);
@@ -140,6 +141,12 @@
       != HUNTED_ISME)
     return 0;
 
+  /* % simulate prefix */
+  if ((parv[1][0] == '%') && (parv[1][1] != '\0')) {
+  	 simulate = 1;
+  	 parv[1]++;
+  }
+
   /*
    * need to find the conf entry first so we can use the server name from
    * the conf entry instead of parv[1] to find out if the server is already
@@ -153,7 +160,7 @@
   /*
    * use aconf->name to look up the server
    */
-  if ((acptr = FindServer(aconf->name))) {
+  if (!simulate && (acptr = FindServer(aconf->name))) {
     sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Server %s already "
 		  "exists from %s", sptr, parv[1], cli_name(cli_from(acptr)));
     return 0;
@@ -164,14 +171,14 @@
    * are ored together.  Oper connects are effected only by D
    * lines (CRULEALL) not d lines (CRULEAUTO).
    */
-  if ((rule = conf_eval_crule(aconf->name, CRULE_ALL))) {
+  if (!simulate && (rule = conf_eval_crule(aconf->name, CRULE_ALL))) {
     sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Disallowed by rule: %s", sptr, rule);
     return 0;
   }
   /*
    * Check to see if the server is juped; if it is, disallow the connect
    */
-  if ((ajupe = jupe_find(aconf->name)) && JupeIsActive(ajupe)) {
+  if (!simulate && (ajupe = jupe_find(aconf->name)) && JupeIsActive(ajupe)) {
     sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Server %s is juped: %s",
 		  sptr, JupeServer(ajupe), JupeReason(ajupe));
     return 0;
@@ -195,19 +202,21 @@
    * Notify all operators about remote connect requests
    */
   sendwallto_group_butone(&me, WALL_WALLOPS, 0,
-                       "Remote CONNECT %s %s from %s", parv[1],
-			parv[2] ? parv[2] : "",
-			get_client_name(sptr, HIDE_IP));
-  log_write(LS_NETWORK, L_INFO, 0, "CONNECT From %C : %s %s", sptr, parv[1],
-	    parv[2] ? parv[2] : "");
+    "Remote %sCONNECT %s %s from %s", simulate ? "simulate " : "",
+    parv[1], parv[2] ? parv[2] : "", get_client_name(sptr, HIDE_IP));
 
-  if (connect_server(aconf, sptr)) {
-    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** Connecting to %s.", sptr,
+  log_write(LS_NETWORK, L_INFO, 0, "CONNECT%s From %C : %s %s",
+            simulate ? " simulate" : "", sptr, parv[1], parv[2] ? parv[2] : "");
+
+  if (connect_server(aconf, sptr, simulate)) {
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** %s to %s.",
+      sptr, simulate ? "Simulating connection" : "Connecting",
 		  aconf->name);
   }
   else {
-    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** Connection to %s failed",
-		  sptr, aconf->name);
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** %s to %s failed",
+      sptr, simulate ? "Simulate connection" : "Connection",
+		  aconf->name);
   }
   aconf->address.port = tmpport;
   return 0;
@@ -230,6 +239,7 @@
   struct ConfItem* aconf;
   struct Client*   acptr;
   struct Jupe*     ajupe;
+  int              simulate = 0;  /* simulate connection */
 
   assert(0 != cptr);
   assert(cptr == sptr);
@@ -271,6 +281,13 @@
         return 0;
     }
   }
+
+  /* % simulate prefix */
+  if ((parv[1][0] == '%') && (parv[1][1] != '\0')) {
+  	 simulate = 1;
+  	 parv[1]++;
+  }
+
   /*
    * need to find the conf entry first so we can use the server name from
    * the conf entry instead of parv[1] to find out if the server is already
@@ -284,7 +301,7 @@
   /*
    * use aconf->name to look up the server, see above
    */
-  if ((acptr = FindServer(aconf->name))) {
+  if (!simulate && (acptr = FindServer(aconf->name))) {
     sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Server %s already "
 		  "exists from %s", sptr, parv[1], cli_name(cli_from(acptr)));
     return 0;
@@ -295,14 +312,15 @@
    * are ored together.  Oper connects are effected only by D
    * lines (CRULEALL) not d lines (CRULEAUTO).
    */
-  if ((rule = conf_eval_crule(aconf->name, CRULE_ALL))) {
-    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Disallowed by rule: %s", sptr, rule);
+  if (!simulate && (rule = conf_eval_crule(aconf->name, CRULE_ALL))) {
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Disallowed by rule: %s",
+                  sptr, rule);
     return 0;
   }
   /*
    * Check to see if the server is juped; if it is, disallow the connect
    */
-  if ((ajupe = jupe_find(aconf->name)) && JupeIsActive(ajupe)) {
+  if (!simulate && (ajupe = jupe_find(aconf->name)) && JupeIsActive(ajupe)) {
     sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Connect: Server %s is juped: %s",
 		  sptr, JupeServer(ajupe), JupeReason(ajupe));
     return 0;
@@ -330,13 +348,15 @@
   tmpport = aconf->address.port;
   aconf->address.port = port;
 
-  if (connect_server(aconf, sptr)) {
-    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** Connecting to %s.", sptr,
+  if (connect_server(aconf, sptr, simulate)) {
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** %s to %s.",
+      sptr, simulate ? "Simulating connection" : "Connecting",
 		  aconf->name);
   }
   else {
-    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** Connection to %s failed",
-		  sptr, aconf->name);
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :*** %s to %s failed",
+      sptr, simulate ? "Simulate connection" : "Connection",
+      aconf->name);
   }
   aconf->address.port = tmpport;
   return 0;
diff -r f8dc614ddef6 ircd/m_server.c
--- a/ircd/m_server.c
+++ b/ircd/m_server.c
@@ -72,8 +72,13 @@
   if (strlen(host) > HOSTLEN)
     host[HOSTLEN] = '\0';
 
+  /* more problem characters above ' ' (\32)
+   *   change to ',' (\44), refuse !"#$%&'()*+, too
+   *   they should not be allowed in servernames
+   *   also now a special char can be used as prefix - snircd
+   */
   for (ch = host; *ch; ch++)
-    if (*ch <= ' ' || *ch > '~')
+    if (*ch <= ',' || *ch > '~')
       break;
   if (*ch || !strchr(host, '.') || strlen(host) > HOSTLEN)
     return NULL;
@@ -494,6 +499,79 @@
     }
 }
 
+/** Handle a test server link - snircd.
+ *
+ * \a parv has the following elements:
+ * \li \a parv[1] is the server name
+ *
+ * See @ref m_functions for discussion of the arguments.
+ * @param[in] cptr Client that sent us the message.
+ * @param[in] sptr Original source of message.
+ * @param[in] parc Number of arguments.
+ * @param[in] parv Argument vector.
+ */
+int test_server_link(struct Client *cptr, struct Client *sptr, int parc, char *parv[])
+{
+  struct ConfItem* aconf; /* conf item attached to cptr */
+  struct Jupe*     ajupe; /* jupe for server */
+  char             *host; /* cleaned up server name */
+  const char      *crule; /* connection rule disallowing connection */
+  int               jupe; /* server is juped */
+
+  assert(NULL != sptr);
+  assert(NULL != cptr);
+  assert(parc > 1);
+
+  /* check server name */
+  if (!(host = clean_servername(parv[1])))
+    return exit_client_msg(cptr, cptr, &me, "Bogus server name (%s)", parv[1]);
+
+  /* set name */
+  ircd_strncpy(cli_name(cptr), host, HOSTLEN);
+
+  /* check connect block */
+  if (conf_check_server(cptr))
+    return exit_client(cptr, cptr, &me, "No Connect block");
+
+  /* check connect block */
+  if (!(aconf = find_conf_byname(cli_confs(cptr), host, CONF_SERVER)))
+    return exit_client_msg(cptr, cptr, &me,
+                           "Access denied. No conf line for server %s", host);
+
+  /* connect block for server and host checks out,
+   *   from here we can announce the result to opers
+   */
+
+  /* check password */
+  if (*aconf->passwd && strcmp(aconf->passwd, cli_passwd(cptr))) {
+    sendwallto_group_butone(&me, WALL_WALLOPS, 0,
+                            "Server test link from %s failed (passwd mismatch)", host);
+
+    return exit_client_msg(cptr, cptr, &me,
+                           "Server test link %s failed (passwd mismatch)", host);
+  }
+
+  /* connect rules */
+  crule = conf_eval_crule(host, CRULE_ALL);
+
+  /* server jupes */
+  jupe = ((ajupe = jupe_find(host)) && JupeIsActive(ajupe));
+
+  /* tell opers */
+  sendwallto_group_butone(&me, WALL_WALLOPS, 0,
+                          "Server test link from %s success (crule: %s, juped: %s)",
+                          host,
+                          (crule != 0) ? "disallowed" : "allowed",
+                          jupe ? "yes" : "no");
+
+  /* tell other end and close connection */
+  return exit_client_msg(cptr, sptr, &me,
+                         "Server test link %s success (crule: %s, juped: %s)",
+                         host,
+                         (crule != 0) ? "disallowed" : "allowed",
+                         jupe ? "yes" : "no");
+}
+
 /** Handle a SERVER message from an unregistered connection.
  *
  * \a parv has the following elements:
@@ -529,6 +607,10 @@
     return exit_client_msg(cptr, cptr, &me,
                            "Cannot connect a server to a user port");
 
+  /* test server link - snircd */
+  if ((parc > 1) && (parc < 8))
+    return test_server_link(cptr, sptr, parc, parv);
+
   if (parc < 8)
   {
     need_more_params(sptr, "SERVER");
diff -r f8dc614ddef6 ircd/s_bsd.c
--- a/ircd/s_bsd.c
+++ b/ircd/s_bsd.c
@@ -146,12 +146,15 @@
  */
 static void connect_dns_callback(void* vptr, const struct irc_in_addr *addr, const char *h_name)
 {
+  int simulate;
   struct ConfItem* aconf = (struct ConfItem*) vptr;
   assert(aconf);
-  aconf->dns_pending = 0;
+  
+  simulate = aconf->dns_simulate;
+  aconf->dns_simulate = aconf->dns_pending = 0;
   if (addr) {
     memcpy(&aconf->address, addr, sizeof(aconf->address));
-    connect_server(aconf, 0);
+    connect_server(aconf, 0, simulate);
   }
   else
     sendto_opmask_butone(0, SNO_OLDSNO, "Connect to %s failed: host lookup",
@@ -319,7 +322,8 @@
     const char* msg = strerror(cli_error(cptr));
     if (!msg)
       msg = "Unknown error";
-    sendto_opmask_butone(0, SNO_OLDSNO, "Connection failed to %s: %s",
+    sendto_opmask_butone(0, SNO_OLDSNO, "%s failed to %s: %s",
+                         IsSimulate(cptr) ? "Simulate connection" : "Connection", 
                          cli_name(cptr), msg);
     return 0;
   }
@@ -337,6 +341,7 @@
    * Create a unique timestamp
    */
   newts = TStime();
+  if (!IsSimulate(cptr)) {
   for (i = HighestFd; i > -1; --i) {
     if ((acptr = LocalClientArray[i]) && 
         (IsServer(acptr) || IsHandshake(acptr))) {
@@ -344,6 +349,7 @@
         newts = cli_serv(acptr)->timestamp + 1;
     }
   }
+  }
   assert(0 != cli_serv(cptr));
 
   cli_serv(cptr)->timestamp = newts;
@@ -354,6 +360,10 @@
   cli_lasttime(cptr) = CurrentTime;
   ClearPingSent(cptr);
 
+  /* simulate just send servername */
+  if (IsSimulate(cptr))
+    sendrawto_one(cptr, MSG_SERVER " %s", cli_name(&me));
+  else
   sendrawto_one(cptr, MSG_SERVER " %s 1 %Tu %Tu J%s %s%s +%s6n :%s",
                 cli_name(&me), cli_serv(&me)->timestamp, newts,
 		MAJOR_PROTOCOL, NumServCap(&me),
@@ -693,7 +703,7 @@
  * @param by Client who requested the connection (if any).
  * @return Non-zero on success; zero on failure.
  */
-int connect_server(struct ConfItem* aconf, struct Client* by)
+int connect_server(struct ConfItem* aconf, struct Client* by, int simulate)
 {
   struct Client*   cptr = 0;
   assert(0 != aconf);
@@ -707,7 +717,7 @@
          ircd_ntoa(&aconf->address.addr)));
 
   if ((cptr = FindClient(aconf->name))) {
-    if (IsServer(cptr) || IsMe(cptr)) {
+    if (!simulate && (IsServer(cptr) || IsMe(cptr))) {
       sendto_opmask_butone(0, SNO_OLDSNO, "Server %s already present from %s", 
                            aconf->name, cli_name(cli_from(cptr)));
       if (by && IsUser(by) && !MyUser(by)) {
@@ -745,6 +755,9 @@
   ircd_strncpy(cli_name(cptr), aconf->name, HOSTLEN);
   ircd_strncpy(cli_sockhost(cptr), aconf->host, HOSTLEN);
 
+  if (simulate)
+    SetSimulate(cptr);
+
   /*
    * Attach config entries to client here rather than in
    * completed_connection. This to avoid null pointer references

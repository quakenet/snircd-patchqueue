Implements user cloaking which may be used to detect spam relays.

Services can use user mode +C to mark clients as "cloaked" and use
ADDCLOAK / CLEARCLOAK to set which other clients may see the cloaked
user.

Cloaked users are automatically deaf, i.e. are not receiving any channel
messages.

User mode +C is not settable on the ircd and instead has to be sent in
the initial NICK message for the user.

diff -r 5afe724e9d85 include/client.h
--- a/include/client.h
+++ b/include/client.h
@@ -190,6 +190,8 @@
 					 privmsgs/notices to users they're not
 					 sharing any channels with (with +k
 					 exceptions */
+    FLAG_CLOAKED,                   /**< SNIRCD_C: client has limited visibility
+					 in channels */
 
     FLAG_LAST_FLAG,                 /**< number of flags */
     FLAG_LOCAL_UMODES = FLAG_LOCOP, /**< First local mode flag */
@@ -626,6 +628,8 @@
 #define IsCommonChansOnly(x)    HasFlag(x, FLAG_COMMONCHANSONLY)
 /** Return non-zero if the client has set mode +Q (common chans restricted). */
 #define IsCommonChansOnlyRestricted(x) HasFlag(x, FLAG_COMMONCHANSONLY_RESTRICTED)
+/** Return non-zero if the client has set mode +C (cloaked). */
+#define IsCloaked(x)            HasFlag(x, FLAG_CLOAKED)
 
 /** Return non-zero if the client has operator or server privileges. */
 #define IsPrivileged(x)         (IsAnOper(x) || IsServer(x))
@@ -695,6 +699,8 @@
 #define SetCommonChansOnly(x)   SetFlag(x, FLAG_COMMONCHANSONLY)
 /** Mark a client as having mode +Q (common chans restricted). */
 #define SetCommonChansOnlyRestricted(x) SetFlag(x, FLAG_COMMONCHANSONLY_RESTRICTED)
+/** Mark a client as having mode +C (cloaked). */
+#define SetCloaked(x)           SetFlag(x, FLAG_CLOAKED)
 
 /** Return non-zero if \a sptr sees \a acptr as an operator. */
 #define SeeOper(sptr,acptr) (IsAnOper(acptr) && (HasPriv(acptr, PRIV_DISPLAY) \
diff -r 5afe724e9d85 include/handlers.h
--- a/include/handlers.h
+++ b/include/handlers.h
@@ -244,6 +244,8 @@
 extern int ms_whois(struct Client*, struct Client*, int, char*[]);
 extern int ms_xquery(struct Client*, struct Client*, int, char*[]);
 extern int ms_xreply(struct Client*, struct Client*, int, char*[]);
+extern int ms_addcloak(struct Client*, struct Client*, int, char*[]);
+extern int ms_clearcloak(struct Client*, struct Client*, int, char*[]);
 
 #endif /* INCLUDED_handlers_h */
 
diff -r 5afe724e9d85 include/msg.h
--- a/include/msg.h
+++ b/include/msg.h
@@ -379,6 +379,14 @@
 #define TOK_XREPLY		"XR"
 #define CMD_XREPLY		MSG_XREPLY, TOK_XREPLY
 
+#define MSG_ADDCLOAK		"ADDCLOAK"
+#define TOK_ADDCLOAK		"CA"
+#define CMD_ADDCLOAK		MSG_ADDCLOAK, TOK_ADDCLOAK
+
+#define MSG_CLEARCLOAK		"CLEARCLOAK"
+#define TOK_CLEARCLOAK		"CU"
+#define CMD_CLEARCLOAK		MSG_CLEARCLOAK, TOK_CLEARCLOAK
+
 /*
  * Constants
  */
diff -r 5afe724e9d85 include/s_user.h
--- a/include/s_user.h
+++ b/include/s_user.h
@@ -105,6 +105,10 @@
 extern unsigned int umode_make_snomask(unsigned int oldmask, char *arg,
                                        int what);
 extern int send_supported(struct Client *cptr);
+extern int can_see_user(struct Client *sptr, struct Client *cloaked);
+extern void add_cloak_target(struct Client *cloaked, struct Client *target);
+extern void remove_cloak_target(struct Client *target);
+extern void clear_cloak_targets(struct Client *cloaked);
 
 #define NAMES_ALL 1 /**< List all users in channel */
 #define NAMES_VIS 2 /**< List only visible users in non-secret channels */
diff -r 5afe724e9d85 include/struct.h
--- a/include/struct.h
+++ b/include/struct.h
@@ -87,6 +87,8 @@
   time_t	     acc_create;                /**< IRC account timestamp */
   unsigned long       acc_id;                    /**< IRC account unique id */
   char*              opername;                  /**< IRC Oper Account name */
+  unsigned long      cloak_count;               /**< How many other clients can see us (0 if not cloaked) */
+  struct Client*     cloak_extra;               /**< The cloaked user we can see */
 };
 
 #endif /* INCLUDED_struct_h */
diff -r 5afe724e9d85 ircd/Makefile.in
--- a/ircd/Makefile.in
+++ b/ircd/Makefile.in
@@ -114,12 +114,14 @@
 	list.c \
 	listener.c \
 	m_account.c \
+	m_addcloak.c \
 	m_admin.c \
 	m_asll.c \
 	m_away.c \
 	m_burst.c \
 	m_cap.c \
 	m_check.c \
+	m_clearcloak.c \
 	m_clearmode.c \
 	m_close.c \
 	m_connect.c \
diff -r 5afe724e9d85 ircd/client.c
--- a/ircd/client.c
+++ b/ircd/client.c
@@ -287,3 +287,4 @@
 
   return marker;
 }
+
diff -r 5afe724e9d85 ircd/m_addcloak.c
--- /dev/null
+++ b/ircd/m_addcloak.c
@@ -0,0 +1,133 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_addcloak.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id: m_addcloak.c,v 1.25 2005/09/13 15:17:46 entrope Exp $
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+#include "config.h"
+
+#include "channel.h"
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "list.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "s_user.h"
+#include "send.h"
+#include "struct.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+
+/*
+ * ms_addcloak - server message handler
+ *
+ *   parv[0] - sender prefix
+ *   parv[1] - user to addcloak
+ *
+ */
+int ms_addcloak(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  struct Client *target;
+  
+  if (parc < 2 || EmptyString(parv[1])) {
+    /*
+     * should have been handled upstream, ignore it.
+     */
+    protocol_violation(sptr,"Too few arguments to addcloak");
+    return need_more_params(sptr,"ADDCLOAK");
+  }
+  if (!(target = findNUser(parv[1]))) {
+    send_reply(sptr, ERR_NOSUCHNICK, parv[1]);
+    return 0;
+  }
+  if (cli_user(sptr)->channel) {
+    protocol_violation(sptr, "Tried to add cloak target for a user who is on 1 or more channels.");
+    return 0;
+  }
+
+  add_cloak_target(sptr, target);
+  sendcmdto_serv_butone(sptr, CMD_ADDCLOAK, sptr, "%s", parv[1]);
+
+  return 0;
+}
diff -r 5afe724e9d85 ircd/m_clearcloak.c
--- /dev/null
+++ b/ircd/m_clearcloak.c
@@ -0,0 +1,123 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_clearcloak.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * $Id: m_clearcloak.c,v 1.25 2005/09/13 15:17:46 entrope Exp $
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+#include "config.h"
+
+#include "channel.h"
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "list.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "s_user.h"
+#include "send.h"
+#include "struct.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+
+/*
+ * ms_clearcloak - server message handler
+ *
+ *   parv[0] - sender prefix
+ *   parv[1] - user to clearcloak
+ *
+ */
+int ms_clearcloak(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  if (IsServer(sptr)) {
+    return protocol_violation(sptr,"Server attempting to clearcloak");
+  }
+  if (cli_user(sptr)->channel) {
+    protocol_violation(sptr, "Tried to clear cloak targets for a user who is on 1 or more channels.");
+    return 0;
+  }
+
+  clear_cloak_targets(sptr);
+  sendcmdto_serv_butone(sptr, CMD_CLEARCLOAK, sptr, "%s", parv[1]);
+
+  return 0;
+}
diff -r 5afe724e9d85 ircd/m_names.c
--- a/ircd/m_names.c
+++ b/ircd/m_names.c
@@ -157,6 +157,9 @@
     if (IsZombie(member) && member->user != sptr)
       continue;
 
+    if (!can_see_user(sptr, member->user))
+      continue;
+
     if (IsDelayedJoin(member) && (member->user != sptr) && !(filter & NAMES_DEL))
         continue;
 
diff -r 5afe724e9d85 ircd/m_who.c
--- a/ircd/m_who.c
+++ b/ircd/m_who.c
@@ -94,6 +94,7 @@
 #include "numeric.h"
 #include "numnicks.h"
 #include "send.h"
+#include "s_user.h"
 #include "whocmds.h"
 
 /* #include <assert.h> -- Now using assert in ircd_log.h */
@@ -316,6 +317,8 @@
           for (member = chptr->members; member; member = member->next_member)
           {
             acptr = member->user;
+            if (!can_see_user(sptr, acptr))
+              continue;
             if ((bitsel & WHOSELECT_OPER) && !SeeOper(sptr,acptr))
               continue;
             if ((acptr != sptr)
@@ -381,6 +384,8 @@
         for (member = chptr->members; member; member = member->next_member)
         {
           acptr = member->user;
+          if (!can_see_user(sptr, acptr))
+            continue;
           if (!(IsUser(acptr) && Process(acptr)))
             continue;           /* Now Process() is at the beginning, if we fail
                                    we'll never have to show this acptr in this query */
@@ -419,6 +424,8 @@
     if ((!(counter < 1)) && matchsel)
       for (acptr = cli_prev(&me); acptr; acptr = cli_prev(acptr))
       {
+        if (!can_see_user(sptr, acptr))
+          continue;
         if (!(IsUser(acptr) && Process(acptr)))
           continue;
 	if ((bitsel & WHOSELECT_OPER) && !SeeOper(sptr,acptr))
diff -r 5afe724e9d85 ircd/m_whois.c
--- a/ircd/m_whois.c
+++ b/ircd/m_whois.c
@@ -153,6 +153,9 @@
     for (chan = user->channel; chan; chan = chan->next_channel)
     {
        chptr = chan->channel;
+
+       if (!can_see_user(sptr, acptr))
+         continue;
        
        if (!ShowChannel(sptr, chptr)
            && !(IsOper(sptr) && IsLocalChannel(chptr->chname)))
diff -r 5afe724e9d85 ircd/parse.c
--- a/ircd/parse.c
+++ b/ircd/parse.c
@@ -645,6 +645,20 @@
     /* UNREG, CLIENT, SERVER, OPER, SERVICE */
     { m_ignore, m_ignore, ms_xreply, m_ignore, m_ignore }
   },
+  {
+    MSG_ADDCLOAK,
+    TOK_ADDCLOAK,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE */
+    { m_ignore, m_ignore, ms_addcloak, m_ignore, m_ignore }
+  },
+  {
+    MSG_CLEARCLOAK,
+    TOK_CLEARCLOAK,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE */
+    { m_ignore, m_ignore, ms_clearcloak, m_ignore, m_ignore }
+  },
 #if WE_HAVE_A_REAL_CAPABILITY_NOW
   {
     MSG_CAP,
diff -r 5afe724e9d85 ircd/s_misc.c
--- a/ircd/s_misc.c
+++ b/ircd/s_misc.c
@@ -235,6 +235,9 @@
       Count_clientdisconnects(bcptr, UserStats);
     else
       Count_remoteclientquits(UserStats, bcptr);
+
+    remove_cloak_target(bcptr);
+    clear_cloak_targets(bcptr);
   }
   else if (IsServer(bcptr))
   {
diff -r 5afe724e9d85 ircd/s_user.c
--- a/ircd/s_user.c
+++ b/ircd/s_user.c
@@ -554,7 +554,8 @@
   { FLAG_SETHOST,     'h' },
   { FLAG_PARANOID,    'P' },
   { FLAG_COMMONCHANSONLY, 'q' },
-  { FLAG_COMMONCHANSONLY_RESTRICTED, 'Q' }
+  { FLAG_COMMONCHANSONLY_RESTRICTED, 'Q' },
+  { FLAG_CLOAKED,     'C' }
 };
 
 /** Length of #userModeList. */
@@ -1261,7 +1262,8 @@
     {
       if (HasFlag(sptr, userModeList[i].flag) &&
           ((userModeList[i].flag != FLAG_ACCOUNT) &&
-          (userModeList[i].flag != FLAG_SETHOST)))
+          (userModeList[i].flag != FLAG_SETHOST) &&
+          (userModeList[i].flag != FLAG_CLOAKED)))
         *m++ = userModeList[i].c;
     }
     *m = '\0';
@@ -1457,6 +1459,11 @@
         else
           ClearCommonChansOnlyRestricted(sptr);
         break;
+      case 'C':
+        if (what == MODE_ADD)
+          SetCloaked(sptr);
+        /* There is no -C */
+        break;
       case 'r':
 	if ((what == MODE_ADD) && *(p + 1)) {
 	  account = *(++p);
@@ -1498,6 +1505,8 @@
       ClearParanoid(sptr);
     if (!FlagHas(&setflags, FLAG_COMMONCHANSONLY_RESTRICTED) && !IsOper(sptr))
       ClearCommonChansOnlyRestricted(sptr);
+    if (!FlagHas(&setflags, FLAG_CLOAKED) && IsCloaked(sptr))
+      ClrFlag(sptr, FLAG_CLOAKED);
 
     /* disallow ordinary users to do MODE -i when feature AUTOINVISIBLE is enabled */
     if (FlagHas(&setflags, FLAG_INVISIBLE) && !IsInvisible(sptr) &&          /* MODE -i */
@@ -2070,3 +2079,84 @@
 
   return 0; /* convenience return, if it's ever needed */
 }
+
+/*
+ * Checks if the target user is cloaked and should not be seen by the source.
+ */
+int can_see_user(struct Client *sptr, struct Client *cloaked)
+{
+  return (cloaked == sptr ||
+          !IsUser(sptr) ||
+          !IsUser(cloaked) ||
+          !IsCloaked(cloaked) ||
+          cli_user(sptr)->cloak_extra == cloaked);
+}
+
+/*
+ * Adds sptr to the list of users who may see through
+ * the cloaked user's cloak.
+ */
+void add_cloak_target(struct Client *cloaked, struct Client *target)
+{
+  struct User *cloaked_user, *target_user;
+
+  cloaked_user = cli_user(cloaked);
+  assert(cloaked_user);
+
+  target_user = cli_user(target);
+  assert(target_user);
+
+  remove_cloak_target(target);
+
+  target_user->cloak_extra = cloaked;
+  cloaked_user->cloak_count++;
+}
+
+/*
+ * Updates the client so that they can no longer see past
+ * another user's cloak.
+ */
+void remove_cloak_target(struct Client *target)
+{
+  struct User *cloaked_user, *target_user;
+
+  target_user = cli_user(target);
+  assert(target_user);
+
+  if (target_user->cloak_extra) {
+    cloaked_user = cli_user(target_user->cloak_extra);
+    assert(cloaked_user);
+
+    cloaked_user->cloak_count--;
+    target_user->cloak_extra = NULL;
+  }
+}
+
+/*
+ * Clears all cloak targets for a user.
+ */
+void clear_cloak_targets(struct Client *cloaked)
+{
+  struct Client *acptr;
+  struct User *cloaked_user, *target_user;
+
+  cloaked_user = cli_user(cloaked);
+  assert(cloaked_user);
+
+  if (cloaked_user->cloak_count == 0)
+    return;
+
+  for (acptr = cli_prev(&me); acptr; acptr = cli_prev(acptr))
+  {
+    target_user = cli_user(acptr);
+
+    if (!target_user)
+      continue;
+
+    if (target_user->cloak_extra == cloaked)
+      target_user->cloak_extra = NULL;
+  }
+
+  cloaked_user->cloak_count = 0;
+}
+
diff -r 5afe724e9d85 ircd/send.c
--- a/ircd/send.c
+++ b/ircd/send.c
@@ -563,6 +563,7 @@
 	 member = member->next_member)
       if (MyConnect(member->user)
           && -1 < cli_fd(cli_from(member->user))
+          && can_see_user(member->user, from)
           && member->user != one
           && cli_sentalong(member->user) != sentalong_marker) {
 	cli_sentalong(member->user) = sentalong_marker;
@@ -606,6 +607,8 @@
     if (!MyConnect(member->user)
         || member->user == one 
         || IsZombie(member)
+        || !can_see_user(member->user, from)
+        || IsCloaked(member->user)
         || (skip & SKIP_DEAF && IsDeaf(member->user))
         || (skip & SKIP_NONOPS && !IsChanOp(member))
         || (skip & SKIP_NONVOICES && !IsChanOp(member) && !HasVoice(member)))
@@ -698,6 +701,8 @@
   for (member = to->members; member; member = member->next_member) {
     /* skip one, zombies, and deaf users... */
     if (IsZombie(member) ||
+        !can_see_user(member->user, from) ||
+        IsCloaked(member->user) ||
         (skip & SKIP_DEAF && IsDeaf(member->user)) ||
         (skip & SKIP_NONOPS && !IsChanOp(member)) ||
         (skip & SKIP_NONVOICES && !IsChanOp(member) && !HasVoice(member)) ||
diff -r 5afe724e9d85 ircd/whocmds.c
--- a/ircd/whocmds.c
+++ b/ircd/whocmds.c
@@ -103,6 +103,9 @@
         break;
   }
 
+  if (!can_see_user(sptr, acptr))
+    chan = NULL;
+
   /* Place the fields one by one in the buffer and send it
      note that fields == NULL means "default query" */
 

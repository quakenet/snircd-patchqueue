Add welcome message functionality.

client commands:
user:
/WELCOME [<server>]
shows welcome messages set, same is shown on connect
feature HIS_REMOTE controls whether ordinary users can request a listing from a remote server

oper:
/WELCOME [<server>] [[$][+]<N> :<message>]
to view welcome messages from a remote server
to set a local welcome message on this server or a remote server
set a global welcome message (server *)
the $ prefix makes the server annouce the welcome message to its clients when setting
the + prefix moves message in N and all after that one spot down, and inserts the new message
in spot N, if there is no room, the last entry is deleted
when an entry is cleared (no text), then all entries after it are moved on place up, so all empty
spots are at the end

server:
:<source> WE <target> [[$][+]<N> <timestamp> <who> :<text>]
who is who set the message, the server puts in the opername when a client sets it.
:<N> is a number 1 to WELCOME_MAX_ENTRIES - currently set at 10 (should be more than we ever need)
that means there is room for 10 local and 10 global entries

STATS W/welcome (/STATS w/userload made case sensitive)
:server 230 nick W Name Target Who Timestamp :Message
:server 227 nick W 1 * opername 1233072583 :Latest news: testing this welcome patch :)
:server 227 nick W 2 * opername 1233072583 :
:server 227 nick W 1 servername opername 1233072590 :This is a test server, expect restarts.
:server 219 nick W :End of /STATS report

listing welcomes or on connect:
:server NOTICE nick :[QuakeNet] Latest news: testing this welcome patch :)
:server NOTICE nick :[server] This is a test server, expect restarts.

announcement is done by a notice by the local server to $* ($servername for local) with the same message
format as for listing welcome messages.
:server NOTICE $* :[QuakeNet] Latest news: testing this welcome patch :)
:server NOTICE $server :[server] This is a test server, expect restarts.


Files:

include/handlers.h
add m_welcome mo_welcome ms_welcome functions

include/features.h
ircd/features.c
add features FEAT_WELCOME and FEAT_HIS_STATS_W

include/msg.h
add MSG_WELCOME TOK_WELCOME CMD_WELCOME

ircd/parse.c
add welcome message functions

include/numeric.h
ircd/s_err.c
add RPL_STATSWELCOME ERR_NOSUCHWELCOME

include/welcome.h
ircd/welcome.c
ircd/m_welcome.c
new

ircd/Makefile.in
add welcome.c and m_welcome.c files

ircd/s_serv.c
add burst welcome message

ircd/s_stats.c
add /STATS W/welcome

ircd/s_user.c
add showing of welcome messages on connect

ircd/s_debug.c
add count and memusage of welcome messages

include/client.h
ircd/client.c
ircd/ircd_lexer.l
ircd/ircd_parser.y
add PRIV_LOCAL_WELCOME PRIV_WELCOME

diff -r 8bf1b05cdfe7 include/client.h
--- a/include/client.h
+++ b/include/client.h
@@ -142,6 +142,8 @@
     PRIV_USER_PRIVACY,  /* oper can bypass user privacy +x etc gives i.e. see real ip's */
     PRIV_CHANNEL_PRIVACY, /* oper can bypass channel privacy i.e. can see modes on channels they are not on and channel keys */ 
     PRIV_SERVERINFO,     /* oper can use /get, /stats, /hash, retrieve remote information */
+    PRIV_WELCOME,        /* oper can WELCOME */
+    PRIV_LOCAL_WELCOME,  /* oper can local WELCOME */
     PRIV_LAST_PRIV /**< number of privileges */
   };
 
diff -r 8bf1b05cdfe7 include/handlers.h
--- a/include/handlers.h
+++ b/include/handlers.h
@@ -138,6 +138,7 @@
 extern int m_version(struct Client*, struct Client*, int, char*[]);
 extern int m_wallchops(struct Client*, struct Client*, int, char*[]);
 extern int m_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int m_welcome(struct Client*, struct Client*, int, char*[]);
 extern int m_who(struct Client*, struct Client*, int, char*[]);
 extern int m_whois(struct Client*, struct Client*, int, char*[]);
 extern int m_whowas(struct Client*, struct Client*, int, char*[]);
@@ -172,6 +173,7 @@
 extern int mo_version(struct Client*, struct Client*, int, char*[]);
 extern int mo_wallops(struct Client*, struct Client*, int, char*[]);
 extern int mo_wallusers(struct Client*, struct Client*, int, char*[]);
+extern int mo_welcome(struct Client*, struct Client*, int, char*[]);
 extern int mo_xquery(struct Client*, struct Client*, int, char*[]);
 extern int mr_error(struct Client*, struct Client*, int, char*[]);
 extern int mr_error(struct Client*, struct Client*, int, char*[]);
@@ -230,6 +232,7 @@
 extern int ms_wallops(struct Client*, struct Client*, int, char*[]);
 extern int ms_wallusers(struct Client*, struct Client*, int, char*[]);
 extern int ms_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int ms_welcome(struct Client*, struct Client*, int, char*[]);
 extern int ms_whois(struct Client*, struct Client*, int, char*[]);
 extern int ms_xquery(struct Client*, struct Client*, int, char*[]);
 extern int ms_xreply(struct Client*, struct Client*, int, char*[]);
diff -r 8bf1b05cdfe7 include/ircd_features.h
--- a/include/ircd_features.h
+++ b/include/ircd_features.h
@@ -101,6 +101,7 @@
   FEAT_IRCD_RES_TIMEOUT,
   FEAT_AUTH_TIMEOUT,
   FEAT_ANNOUNCE_INVITES,
+  FEAT_WELCOME,
 
   /* features that affect all operators */
   FEAT_EXTENDED_CHECKCMD,
@@ -142,6 +143,7 @@
   FEAT_HIS_STATS_u,
   FEAT_HIS_STATS_U,
   FEAT_HIS_STATS_v,
+  FEAT_HIS_STATS_W,
   FEAT_HIS_STATS_w,
   FEAT_HIS_STATS_x,
   FEAT_HIS_STATS_y,
diff -r 8bf1b05cdfe7 include/msg.h
--- a/include/msg.h
+++ b/include/msg.h
@@ -196,6 +196,10 @@
 #define TOK_NOTICE              "O"
 #define CMD_NOTICE		MSG_NOTICE, TOK_NOTICE
 
+#define MSG_WELCOME             "WELCOME"       /* WELC */
+#define TOK_WELCOME             "WE"
+#define CMD_WELCOME		MSG_WELCOME, TOK_WELCOME
+
 #define MSG_WALLCHOPS           "WALLCHOPS"     /* WC */
 #define TOK_WALLCHOPS           "WC"
 #define CMD_WALLCHOPS		MSG_WALLCHOPS, TOK_WALLCHOPS
diff -r 8bf1b05cdfe7 include/numeric.h
--- a/include/numeric.h
+++ b/include/numeric.h
@@ -116,6 +116,7 @@
 	RPL_STATSGLINE	     227	   Dalnet 
 	RPL_STATSVLINE	     227	   unreal */
 #define RPL_STATSALINE       226        /* Hybrid, Undernet */
+#define RPL_STATSWELCOME     227        /* QuakeNet extension */
 #define RPL_STATSQLINE       228        /* Undernet extension */
 
 /*      RPL_SERVICEINFO      231	unused */
@@ -440,6 +441,8 @@
 /*      ERR_GHOSTEDCLIENT    503           efnet */
 /*	ERR_VWORLDWARN	     503	   austnet */
 
+#define ERR_NOSUCHWELCOME    509        /* QuakeNet extension */
+
 #define ERR_SILELISTFULL     511        /* Undernet extension */
 /*      ERR_NOTIFYFULL       512           aircd */
 /*	ERR_TOOMANYWATCH     512           Numeric List: Dalnet */
diff -r 8bf1b05cdfe7 include/welcome.h
--- /dev/null
+++ b/include/welcome.h
@@ -0,0 +1,79 @@
+#ifndef INCLUDED_welcome_h
+#define INCLUDED_welcome_h
+/*
+ * IRC - Internet Relay Chat, include/welcome.h
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ * Copyright (C) 2000 Kevin L. Mitchell <klmitch@mit.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/** @file
+ * @brief  Interface and declarations for welcome message handling.
+ */
+
+struct Client;
+struct StatDesc;
+
+/* Maximum number of welcome entries (per type; X global, X local) */
+#define WELCOME_MAX_ENTRIES  10
+/* Maximum length of a welcome message */
+#define WELCOMELEN TOPICLEN
+
+
+/* Test if a welcome entry is in a valid range */
+#define WelcomeArrayIsValid(x)   ((unsigned) (x) <= 2 * WELCOME_MAX_ENTRIES -1)
+/* Test if a welcome name is in a valid range */
+#define WelcomeNameIsValid(x)    ((unsigned) (x) <= WELCOME_MAX_ENTRIES)
+/* Test if a welcome entry is set */
+#define WelcomeIsSet(x)          (WelcomeArray[(x)].lastmod > 0)
+/* Test if a welcome entry is empty */
+#define WelcomeIsEmpty(x)        (*WelcomeArray[(x)].text == 0)
+
+/* Get welcome create timestamp */
+#define WelcomeCreate(x)         (WelcomeArray[(x)].create)
+/* Get welcome lastmod timestamp */
+#define WelcomeLastMod(x)        (WelcomeArray[(x)].lastmod)
+/* Get welcome who info */
+#define WelcomeWho(x)            (WelcomeArray[(x)].who)
+/* Get welcome text */
+#define WelcomeText(x)           (WelcomeArray[(x)].text)
+
+
+/* Describes a Welcome message entry. */
+struct Welcome {
+  time_t             create;               /**< When it was set */
+  time_t             lastmod;              /**< Last modification timestamp (used for resolving conflicts in burst) */
+  char               text[WELCOMELEN + 1]; /**< Message */
+  char               who[ACCOUNTLEN + 1];  /**< Who set it */
+};
+
+/** Welcome type flags */
+#define WELCOME_LOCAL      0x01 /**< welcome is local */
+/** Welcome action flags */
+#define WELCOME_ANNOUNCE   0x02 /**< announce new welcome to users */
+#define WELCOME_INSERT     0x04 /**< insert welcome message, move down all others one place */
+#define WELCOME_DELETE     0x08 /**< delete welcome message, move up all others one place */
+#define WELCOME_INCLASTMOD 0x10 /**< increase lastmod if needed */
+#define WELCOME_FORCE      0x20 /**< force change, bypass lastmod check */
+
+extern int welcome_do(struct Client *cptr, struct Client *sptr, char *name,
+  time_t create, time_t lastmod, char *who, char *text, unsigned int flags);
+extern void welcome_burst(struct Client *cptr);
+extern int welcome_list(struct Client *sptr, int connect);
+extern void welcome_stats(struct Client *sptr, const struct StatDesc *sd, char *param);
+extern int welcome_memory_count(size_t *we_size);
+
+#endif /* INCLUDED_welcome_h */
diff -r 8bf1b05cdfe7 ircd/Makefile.in
--- a/ircd/Makefile.in
+++ b/ircd/Makefile.in
@@ -186,6 +186,7 @@
 	m_wallops.c \
 	m_wallusers.c \
 	m_wallvoices.c \
+	m_welcome.c \
 	m_who.c \
 	m_whois.c \
 	m_whowas.c \
@@ -215,6 +216,7 @@
 	send.c \
 	uping.c \
 	userload.c \
+	welcome.c \
 	whocmds.c \
 	whowas.c \
 	y.tab.c
@@ -1161,6 +1163,11 @@
   ../include/ircd_reply.h ../include/ircd_string.h \
   ../include/ircd_chattr.h ../include/msg.h ../include/numeric.h \
   ../include/numnicks.h ../include/s_user.h ../include/send.h
+m_welcome.o: m_welcome.c ../config.h ../include/channel.h \
+  ../include/client.h ../include/hash.h ../include/ircd.h ../include/ircd_log.h \
+  ../include/ircd_reply.h ../include/ircd_string.h ../include/msg.h \
+  ../include/numeric.h ../include/numnicks.h ../include/s_user.h \
+  ../include/send.h ../include/welcome.h
 m_who.o: m_who.c ../config.h ../include/channel.h ../include/ircd_defs.h \
   ../include/res.h ../config.h ../include/client.h ../include/dbuf.h \
   ../include/msgq.h ../include/ircd_events.h ../include/ircd_handler.h \
@@ -1422,6 +1429,13 @@
   ../include/numnicks.h ../include/querycmds.h ../include/ircd_features.h \
   ../include/s_misc.h ../include/s_stats.h ../include/send.h \
   ../include/struct.h ../include/sys.h
+welcome.o: welcome.c ../config.h ../include/client.h \
+  ../include/hash.h ../include/ircd.h ../include/ircd_alloc.h \
+  ../include/ircd_features.h ../include/ircd_log.h ../include/ircd_reply.h \
+  ../include/match.h ../include/msg.h ../include/numeric.h \
+  ../include/numnicks.h ../include/s_debug.h ../include/s_bsd.h \
+  ../include/s_misc.h ../include/send.h ../include/struct.h \
+  ../include/sys.h ../include/welcome.h
 whocmds.o: whocmds.c ../config.h ../include/whocmds.h \
   ../include/channel.h ../include/ircd_defs.h ../include/res.h \
   ../config.h ../include/client.h ../include/dbuf.h ../include/msgq.h \
diff -r 8bf1b05cdfe7 ircd/client.c
--- a/ircd/client.c
+++ b/ircd/client.c
@@ -177,6 +177,7 @@
     FlagSet(&privs_local, PRIV_WHOX);
     FlagSet(&privs_local, PRIV_DISPLAY);
     FlagSet(&privs_local, PRIV_FORCE_LOCAL_OPMODE);
+    FlagSet(&privs_local, PRIV_LOCAL_WELCOME);
 
     privs_defaults_set = 1;
   }
@@ -223,6 +224,7 @@
     ClrPriv(client, PRIV_JUPE);
     ClrPriv(client, PRIV_OPMODE);
     ClrPriv(client, PRIV_BADCHAN);
+    ClrPriv(client, PRIV_WELCOME);
   }
 }
 
@@ -244,7 +246,7 @@
   P(CHANSERV),       P(XTRA_OPER),      P(NOIDLE),        P(FREEFORM),
   P(PARANOID),       P(CHECK),          P(WALL),          P(CLOSE),
   P(ROUTE),          P(ROUTEINFO),      P(SERVERINFO),    P(CHANNEL_PRIVACY),
-  P(USER_PRIVACY),
+  P(USER_PRIVACY),   P(WELCOME),        P(LOCAL_WELCOME),
 #undef P
   { 0, 0 }
 };
diff -r 8bf1b05cdfe7 ircd/ircd_features.c
--- a/ircd/ircd_features.c
+++ b/ircd/ircd_features.c
@@ -366,6 +366,7 @@
   F_I(IRCD_RES_TIMEOUT, 0, 4, 0),
   F_I(AUTH_TIMEOUT, 0, 9, 0),
   F_B(ANNOUNCE_INVITES, 0, 0, 0),
+  F_B(WELCOME, 0, 1, 0),
 
   /* features that affect all operators */
   F_B(EXTENDED_CHECKCMD, 0, 0, 0),
@@ -407,6 +408,7 @@
   F_B(HIS_STATS_u, 0, 1, 0),
   F_B(HIS_STATS_U, 0, 1, 0),
   F_B(HIS_STATS_v, 0, 1, 0),
+  F_B(HIS_STATS_W, 0, 1, 0),
   F_B(HIS_STATS_w, 0, 1, 0),
   F_B(HIS_STATS_x, 0, 1, 0),
   F_B(HIS_STATS_y, 0, 1, 0),
diff -r 8bf1b05cdfe7 ircd/ircd_lexer.l
--- a/ircd/ircd_lexer.l
+++ b/ircd/ircd_lexer.l
@@ -166,6 +166,8 @@
   { "serverinfo", TPRIV_SERVERINFO },
   { "user_privacy", TPRIV_USER_PRIVACY },
   { "channel_privacy", TPRIV_CHANNEL_PRIVACY },
+  { "local_welcome", TPRIV_LOCAL_WELCOME },
+  { "welcome", TPRIV_WELCOME },
   { NULL, 0 }
 };
 static int ntokens;
diff -r 8bf1b05cdfe7 ircd/ircd_parser.y
--- a/ircd/ircd_parser.y
+++ b/ircd/ircd_parser.y
@@ -189,6 +189,7 @@
 %token TPRIV_CHANSERV TPRIV_XTRA_OPER TPRIV_NOIDLE TPRIV_FREEFORM TPRIV_PARANOID
 %token TPRIV_CHECK TPRIV_WALL TPRIV_CLOSE TPRIV_ROUTE TPRIV_ROUTEINFO TPRIV_SERVERINFO
 %token TPRIV_CHANNEL_PRIVACY TPRIV_USER_PRIVACY TPRIV_LIST_CHAN 
+%token TPRIV_LOCAL_WELCOME TPRIV_WELCOME
 /* and some types... */
 %type <num> sizespec
 %type <num> timespec timefactor factoredtimes factoredtime
@@ -703,6 +704,8 @@
           TPRIV_SERVERINFO { $$ = PRIV_SERVERINFO ; } |
           TPRIV_CHANNEL_PRIVACY { $$ = PRIV_CHANNEL_PRIVACY ; } |
           TPRIV_USER_PRIVACY { $$ = PRIV_USER_PRIVACY ; } |
+          TPRIV_LOCAL_WELCOME { $$ = PRIV_LOCAL_WELCOME; } |
+          TPRIV_WELCOME { $$ = PRIV_WELCOME; } |
           TPRIV_PARANOID { $$ = PRIV_PARANOID; } ;
 yesorno: YES { $$ = 1; } | NO { $$ = 0; };
 
diff -r 8bf1b05cdfe7 ircd/m_welcome.c
--- /dev/null
+++ b/ircd/m_welcome.c
@@ -0,0 +1,346 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_welcome.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+
+#include "client.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "msg.h"
+#include "numeric.h"
+#include "s_user.h"
+#include "welcome.h"
+
+
+/*
+ * m_welcome - local generic message handler
+ *
+ *
+ * WELCOME
+ *
+ * listing:
+ *   parv[0] = Send prefix
+ *
+ *
+ * WELCOME [<server>]
+ *
+ * remote listing:
+ *   parv[0] = Send prefix
+ *   parv[1] = Target
+ *
+ */
+int m_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  /* feature disabled */
+  if (!feature_bool(FEAT_WELCOME))
+    return send_reply(sptr, ERR_DISABLED, "WELCOME");
+
+  /* only opers can set the welcome messages */
+  if (parc > 2)
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* remote listing request, see if it is for me or a remote server
+   *  check FEAT_HIS_REMOTE to decide if an ordinary user can do this
+   */
+  if ((parc > 1) && (hunt_server_cmd(sptr, CMD_WELCOME, cptr, feature_int(FEAT_HIS_REMOTE),
+        "%C", 1, parc, parv) != HUNTED_ISME))
+    return 0;
+
+  /* local listing */
+  return welcome_list(sptr, 0);
+}
+
+
+/*
+ * mo_welcome - oper message handler
+ *
+ *
+ * WELCOME
+ *
+ * listing:
+ *   parv[0] = Send prefix
+ *
+ *
+ * WELCOME <server>
+ *
+ * remote listing:
+ *   parv[0] = Send prefix
+ *   parv[1] = Target
+ *
+ *
+ * WELCOME <server> <name> :<text>
+ *
+ * set global or on remote server:
+ *   parv[0] = Send prefix
+ *   parv[1] = Target: server or * for global (or left out for this server)
+ *   parv[2] = Name
+ *   parv[3] = Text
+ *
+ */
+int mo_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target, *name, *who, *text, pattern[BUFSIZE];
+  time_t create, lastmod;
+  unsigned int flags = 0;
+  int local = 0;
+
+  /* feature disabled */
+  if (!feature_bool(FEAT_WELCOME))
+    return send_reply(sptr, ERR_DISABLED, "WELCOME");
+
+  /* TODO: move feature check here? */
+  /* remote listing request, see if it is for me or a remote server */
+  if ((parc == 2) && (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C", 1, parc, parv) != HUNTED_ISME))
+    return 0;
+
+  /* local listing */
+  if (parc <= 2)
+    return welcome_list(sptr, 0);
+
+  /* check PRIVS */
+  /* local - need PRIV LOCAL_WELCOME or WELCOME */
+  if (parc == 3 && !HasPriv(sptr,PRIV_LOCAL_WELCOME) && !HasPriv(sptr,PRIV_WELCOME))
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* global or remote - need PRIV WELCOME */
+  if (parc >= 4 && !HasPriv(sptr,PRIV_WELCOME))
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* set the parameters */
+
+  /* target not given, only name - setting local welcome */
+  if (parc < 4) {
+    local++;
+    target = cli_name(&me);
+    name = parv[1];
+    flags |= WELCOME_LOCAL;
+
+  /* target and name given */
+  } else {
+    target = parv[1];
+    name = parv[2];
+  }
+  create = TStime();
+  lastmod = TStime();
+  who = cli_user(sptr)->opername;
+  text = parv[parc - 1];
+
+  /* target is not global */
+  if (!(target[0] == '*' && target[1] == '\0') && !local) {
+
+    /* build a pattern for hunt_server_cmd since we do not have all we need in parv */
+    ircd_snprintf(0, pattern, sizeof(pattern), "%s %s %Tu %Tu %s :%s", "%C", name, create, lastmod, who, text);
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, pattern, 1, 2, parv) != HUNTED_ISME)
+      return 0;
+
+   /* else it is a local welcome, for me */
+    flags |= WELCOME_LOCAL; 
+  }
+
+  /* check for anounce prefix */
+  if (*name == '$') {
+     name++;
+     /* only allow announce by oper for local welcome */
+     if (flags & WELCOME_LOCAL)
+       flags |= WELCOME_ANNOUNCE;
+  }
+
+  /* check for force prefix */
+  if (*name == '!') {
+     name++;
+     flags |= WELCOME_FORCE;
+  }
+
+  /* check for insert prefix */
+  if (*name == '+') {
+     name++;
+     flags |= WELCOME_INSERT;
+  }
+
+  /* check for delete prefix */
+  else if (*name == '-') {
+     name++;
+     flags |= WELCOME_DELETE;
+  }
+
+  /* empty text, set WELCOME_DELETE flag */
+  if (*text == 0)
+    flags |= WELCOME_DELETE;
+
+  /* and do it */
+  return welcome_do(cptr, sptr, name, create, lastmod, who, text, flags);
+}
+
+
+/*
+ * ms_welcome - server message handler
+ *
+ *
+ * <source> WE <target>
+ *
+ * remote listing:
+ *   parv[0] = Send prefix
+ *   parv[1] = Target: server numeric or * for global
+ *
+ *
+ * <source> WE <target> <name> <create> <lastmod> <who> :<text>
+ *
+ * set global or on remote server:
+ *   parv[0] = Send prefix
+ *   parv[1] = Target: server numeric or * for global
+ *   parv[2] = Name
+ *   parv[3] = Create
+ *   parv[4] = LastMod
+ *   parv[5] = Who
+ *   parv[6] = Text
+ *
+ */
+int ms_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target, *name, *who, *text;
+  time_t create, lastmod;
+  unsigned int flags = 0;
+  
+  /* not enough - complain */
+  if (parc < 2) {
+    protocol_violation(cptr, "Received too few parameters for WELCOME from %C (got %d - need 2)", sptr, parc);
+    return need_more_params(sptr, "WELCOME");
+  }
+
+  /* remote listing request, see if it is for me or a remote server */
+  if (parc == 2) {
+    if (IsServer(sptr))
+      return protocol_violation(cptr, "Received WELCOME listing request from server %C", sptr);
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C", 1, parc, parv) != HUNTED_ISME)
+      return 0;
+    return welcome_list(sptr, 0);
+  }
+
+  /* we need at least 7 parameters to continue - complain */  
+  if (parc < 7) {
+    protocol_violation(cptr, "Received too few parameters for WELCOME from %C (got %d - need 7)", sptr, parc);
+    return need_more_params(sptr, "WELCOME");
+  }
+
+  /* set the parameters */
+  target = parv[1];
+  name = parv[2];
+  create = atoi(parv[3]);
+  lastmod = atoi(parv[4]);
+  who = parv[5];
+  text = parv[parc - 1]; /* parse reason as last parameter */
+
+  /* target is not global */
+  if (!(target[0] == '*' && target[1] == '\0')) {
+
+    /* not for me, and forward it */
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C %s %s %s %s :%s", 1, parc, parv) != HUNTED_ISME)
+      return 0;
+
+    /* local welcome for me */
+    flags |= WELCOME_LOCAL; 
+  }
+
+  /* check for anounce prefix */
+  if (*name == '$') {
+     name++;
+     flags |= WELCOME_ANNOUNCE;
+  }
+
+  /* check for force prefix */
+  if (*name == '!') {
+     name++;
+     flags |= WELCOME_FORCE;
+  }
+
+  /* check for insert prefix */
+  if (*name == '+') {
+     name++;
+     flags |= WELCOME_INSERT;
+  }
+
+  /* check for delete prefix */
+  else if (*name == '-') {
+     name++;
+     flags |= WELCOME_DELETE;
+  }
+
+  /* and do it */
+  return welcome_do(cptr, sptr, name, create, lastmod, who, text, flags);
+}
diff -r 8bf1b05cdfe7 ircd/parse.c
--- a/ircd/parse.c
+++ b/ircd/parse.c
@@ -661,6 +661,15 @@
     /* UNREG, CLIENT, SERVER, OPER, SERVICE */
     { m_unregistered, m_not_oper, ms_check, mo_check, m_ignore }
   },
+  
+  /* add command for WELCOME */
+  {
+    MSG_WELCOME,
+    TOK_WELCOME,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE, HELP */
+    { m_unregistered, m_welcome, ms_welcome, mo_welcome, m_ignore }
+  },
 
   /* This command is an alias for QUIT during the unregistered part of
    * of the server.  This is because someone jumping via a broken web
diff -r 8bf1b05cdfe7 ircd/s_debug.c
--- a/ircd/s_debug.c
+++ b/ircd/s_debug.c
@@ -50,6 +50,7 @@
 #include "send.h"
 #include "struct.h"
 #include "sys.h"
+#include "welcome.h"
 #include "whowas.h"
 
 /* #include <assert.h> -- Now using assert in ircd_log.h */
@@ -231,7 +232,8 @@
       aw = 0,                   /* aways set */
       wwa = 0,                  /* whowas aways */
       gl = 0,                   /* glines */
-      ju = 0;                   /* jupes */
+      ju = 0,                   /* jupes */
+      we = 0;                   /* welcomes */
 
   size_t chm = 0,               /* memory used by channels */
       chbm = 0,                 /* memory used by channel bans */
@@ -244,6 +246,7 @@
       wwm = 0,                  /* whowas array memory used */
       glm = 0,                  /* memory used by glines */
       jum = 0,                  /* memory used by jupes */
+      wem = 0,                  /* memory used by welcomes */
       com = 0,                  /* memory used by conf lines */
       dbufs_allocated = 0,      /* memory used by dbufs */
       dbufs_used = 0,           /* memory used by dbufs */
@@ -351,6 +354,10 @@
   send_reply(cptr, SND_EXPLICIT | RPL_STATSDEBUG,
 	     ":Glines %d(%zu) Jupes %d(%zu)", gl, glm, ju, jum);
 
+  we = welcome_memory_count(&wem);
+  send_reply(cptr, SND_EXPLICIT | RPL_STATSDEBUG,
+	     ":Welcomes %d(%zu)", we, wem);
+
   send_reply(cptr, SND_EXPLICIT | RPL_STATSDEBUG,
 	     ":Hash: client %d(%zu), chan is the same", HASHSIZE,
 	     sizeof(void *) * HASHSIZE);
diff -r 8bf1b05cdfe7 ircd/s_err.c
--- a/ircd/s_err.c
+++ b/ircd/s_err.c
@@ -486,7 +486,7 @@
 /* 226 */
   { RPL_STATSALINE, "%s", "226" },
 /* 227 */
-  { 0 },
+  { RPL_STATSWELCOME, "W %d %s %s %Tu %Tu :%s", "227" },
 /* 228 */
   { RPL_STATSQLINE, "Q %s :%s", "228" },
 /* 229 */
@@ -1050,7 +1050,7 @@
 /* 508 */
   { 0 },
 /* 509 */
-  { 0 },
+  { ERR_NOSUCHWELCOME, "%s :No such welcome", "509" },
 /* 510 */
   { 0 },
 /* 511 */
diff -r 8bf1b05cdfe7 ircd/s_serv.c
--- a/ircd/s_serv.c
+++ b/ircd/s_serv.c
@@ -57,6 +57,7 @@
 #include "struct.h"
 #include "sys.h"
 #include "userload.h"
+#include "welcome.h"
 
 /* #include <assert.h> -- Now using assert in ircd_log.h */
 #include <stdlib.h>
@@ -196,6 +197,7 @@
    */
   gline_burst(cptr);
   jupe_burst(cptr);
+  welcome_burst(cptr);
 
   /*
    * Pass on my client information to the new server
diff -r 8bf1b05cdfe7 ircd/s_stats.c
--- a/ircd/s_stats.c
+++ b/ircd/s_stats.c
@@ -54,6 +54,7 @@
 #include "send.h"
 #include "struct.h"
 #include "userload.h"
+#include "welcome.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -650,9 +651,12 @@
   { 'V', "vserversmach", (STAT_FLAG_OPERFEAT | STAT_FLAG_VARPARAM | STAT_FLAG_CASESENS), FEAT_HIS_STATS_v,
     stats_servers_verbose, 0,
     "Verbose server information." },
-  { 'w', "userload", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_w,
+  { 'w', "userload", STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS, FEAT_HIS_STATS_w,
     calc_load, 0,
     "Userload statistics." },
+  { 'W', "welcome", STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS, FEAT_HIS_STATS_W,
+    welcome_stats, 0,
+    "Welcome messages." },
   { 'x', "memusage", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_x,
     stats_meminfo, 0,
     "List usage information." },
diff -r 8bf1b05cdfe7 ircd/s_user.c
--- a/ircd/s_user.c
+++ b/ircd/s_user.c
@@ -63,6 +63,7 @@
 #include "userload.h"
 #include "version.h"
 #include "whowas.h"
+#include "welcome.h"
 
 #include "handlers.h" /* m_motd and m_lusers */
 
@@ -402,6 +403,10 @@
 
     IPcheck_connect_succeeded(sptr);
 
+    /* send welcome */
+    if (feature_bool(FEAT_WELCOME))
+      welcome_list(sptr, 1);
+
     /* TODO: */
     /* apply auto sethost if needed */
     apply_spoofblock(sptr);
diff -r 8bf1b05cdfe7 ircd/welcome.c
--- /dev/null
+++ b/ircd/welcome.c
@@ -0,0 +1,843 @@
+/*
+ * IRC - Internet Relay Chat, ircd/welcome.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Finland
+ * Copyright (C) 2000 Kevin L. Mitchell <klmitch@mit.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/** @file
+ * @brief Implementation of welcome message handling functions.
+ */
+
+#include "client.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "msg.h"
+#include "numeric.h"
+#include "s_bsd.h"
+#include "s_debug.h"
+#include "send.h"
+#include "welcome.h"
+
+
+/** List of welcome messages - first MAX for global, second MAX for local */
+static struct Welcome WelcomeArray[WELCOME_MAX_ENTRIES * 2] = { { 0 } };
+
+
+/** Allocate a new welcome with the given parameters.
+ * @param[in] name Name of the welcome message.
+ * @param[in] text The welcome message.
+ * @param[in] who Who set it.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @return name Array number of the welcome set.
+ */
+static int 
+welcome_make(int name, char *text, char *who, time_t create, time_t lastmod, unsigned int flags)
+{
+
+  /* assert */
+  assert(WelcomeArrayIsValid(name));
+  assert(NULL != text);
+  assert(NULL != who);
+  assert((flags & WELCOME_FORCE) || lastmod > 0);   /* lastmod must not be 0 unless forced */
+  assert(!(flags & WELCOME_LOCAL) &&
+           ((flags & WELCOME_FORCE) ||
+             lastmod >= WelcomeLastMod(name)));   /* lastmod may not decrease for global welcome unless forced */
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_make(%d, \"%s\", \"%s\", %Tu, %Tu, "
+                      "FLAGS(0x%04x): local=%s announce=%s force=%s insert=%s delete=%s inclastmod=%s)",
+    name, text, who, create, lastmod, flags,
+      (flags & WELCOME_LOCAL) ? "yes" : "no",
+      (flags & WELCOME_ANNOUNCE) ? "yes" : "no",
+      (flags & WELCOME_FORCE) ? "yes" : "no",
+      (flags & WELCOME_INSERT) ? "yes" : "no",
+      (flags & WELCOME_DELETE) ? "yes" : "no",
+      (flags & WELCOME_INCLASTMOD) ? "yes" : "no"));
+
+  /* forced and lastmod is zero, clear text and who */
+  if (flags & WELCOME_FORCE && lastmod == 0) {
+    text = "";
+    who = "";
+  }
+
+  /* store it */
+  ircd_strncpy(WelcomeArray[name].text, text, WELCOMELEN);
+  ircd_strncpy(WelcomeArray[name].who, who, ACCOUNTLEN);
+
+  if (flags & WELCOME_INCLASTMOD &&        /* take current lastmod+1 if needed*/
+       !(flags & WELCOME_FORCE) &&         /* not forced */
+         WelcomeLastMod(name) >= lastmod)  /* current lastmod greater or equal than lastmod*/
+    WelcomeArray[name].lastmod = WelcomeLastMod(name) +1;
+  else
+    WelcomeArray[name].lastmod = lastmod;
+
+  WelcomeArray[name].create = create;
+
+  return name;
+}
+
+
+/** Propagate a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @param[in] who Who set this message.
+ * @param[in] text The welcome message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_propagate(struct Client *cptr, struct Client *sptr, int nameint,
+  time_t create, time_t lastmod, char *who, char *text, unsigned int flags)
+{
+  /* assert */
+  assert(NULL != sptr);
+  assert(NULL != cptr);
+  assert(WelcomeNameIsValid(nameint));
+  assert(lastmod >= 0);
+  assert(lastmod > 0 || flags & WELCOME_FORCE);   /* lastmod must not be 0 unless forced */
+  assert(!(flags & WELCOME_LOCAL));  /* must not be local */
+
+  sendcmdto_serv_butone(sptr, CMD_WELCOME, cptr, "* %s%s%s%s%d %Tu %Tu %s :%s",
+    (flags & WELCOME_ANNOUNCE) ? "$" : "",
+    (flags & WELCOME_FORCE) ? "!" : "",
+    (flags & WELCOME_INSERT) ? "+" : "",
+    (flags & WELCOME_DELETE) ? "-" : "",
+    nameint, create, lastmod, who, text);
+
+  return 0;
+}
+
+
+/** Resend a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Name of the array item.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_resend(struct Client *cptr, int nameint, int namearray, unsigned int flags)
+{
+
+  int name;                 /* loop variable */
+
+  /* assert */
+  assert(NULL != cptr);
+  assert(IsServer(cptr));
+  assert(WelcomeNameIsValid(nameint));
+  assert(WelcomeArrayIsValid(namearray));
+  assert(nameint - 1 == namearray);
+  assert(!(flags & WELCOME_LOCAL));   /* must not be local */
+  assert(!(flags & WELCOME_FORCE));   /* must not be forced */
+
+  /* send our version */
+  sendcmdto_one(&me, CMD_WELCOME, cptr, "* %d %Tu %Tu %s :%s",
+    nameint,
+    WelcomeCreate(namearray), WelcomeLastMod(namearray),
+    WelcomeWho(namearray), WelcomeText(namearray));
+
+  /* bad welcome did not have insert or delete prefix */
+  if (!(flags & (WELCOME_INSERT|WELCOME_DELETE)))
+    return 0;
+
+  /* loop over global entries - nameint+1 to max - 1 */
+  for (name = namearray +1; name <= WELCOME_MAX_ENTRIES - 1; name++) {
+    if (!WelcomeIsSet(name))   /* not set, force */
+      sendcmdto_one(&me, CMD_WELCOME, cptr, "* !%d 0 0 0 :", name +1);
+     else   /* send our version */
+      sendcmdto_one(&me, CMD_WELCOME, cptr, "* %d %Tu %Tu %s :%s",
+        name +1,
+        WelcomeCreate(name), WelcomeLastMod(name),
+        WelcomeWho(name), WelcomeText(name));
+  }
+
+  return 0;
+}
+
+
+/** Log a welcome message.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] msg The message to show.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_log(struct Client *sptr, char *msg, unsigned int flags)
+{
+  /* assert */
+  assert(NULL != sptr);
+  assert(NULL != msg);
+
+  /* inform ops */
+  sendto_opmask_butone(0, SNO_OLDSNO, "%s %s",
+    (feature_bool(FEAT_HIS_SNOTICES) || IsServer(sptr)) ?
+    get_client_name_and_opername(sptr) : cli_name((cli_user(sptr))->server), msg);
+
+  /* log it */
+  log_write(LS_NETWORK, L_INFO, LOG_NOSNOTICE, "%s %s", get_client_name_and_opername(sptr), msg);
+
+  /* welcome by remote oper, inform of success */
+  if ((flags & WELCOME_LOCAL) && IsUser(sptr) && !MyConnect(sptr)) {
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :%s %s",
+      sptr, get_client_name_and_opername(sptr), msg);
+
+    /* TODO: wallops all local changes, by both local and remote opers? */
+    /* tell all opers about the local message being set remotely */
+    sendwallto_group_butone(&me, WALL_WALLOPS, 0, "%s %s", get_client_name_and_opername(sptr), msg);
+  }
+
+  return 0;
+}
+
+
+/** Announce a welcome message to local clients.
+ * @param[in] name Welcome message to announce.
+ * @param[in] flags Flags to set on welcome.
+ */
+void
+welcome_announce(int name, unsigned int flags)
+{
+  struct Client *acptr;                 /* local user */
+  struct MsgBuf *msgbuf;                /* message to send */
+  int i;                                /* loop variable */
+
+  /* assert */
+  assert(flags & WELCOME_ANNOUNCE);
+  assert(WelcomeArrayIsValid(name));
+  assert(WelcomeIsSet(name));
+  assert(!WelcomeIsEmpty(name));  
+
+  /* build msgbuf */
+  msgbuf = msgq_make(0, ":%C %s $%s :[%s] %s", &me, MSG_NOTICE,
+    (flags & WELCOME_LOCAL) ? cli_name(&me) : "*",
+    (flags & WELCOME_LOCAL) ? cli_name(&me) : feature_str(FEAT_NETWORK),
+    WelcomeText(name));
+
+  /* go over local clients */
+  for (i = HighestFd; i > 0; --i) {
+
+    /* skip unregistered clients, skip servers */
+    if (!(acptr = LocalClientArray[i]) || !IsRegistered(acptr) || IsServer(acptr))
+      continue;
+
+    /* send it away */ 
+    send_buffer(acptr, msgbuf, 0);
+  }
+}
+
+
+/** Set a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @param[in] who Who set this message.
+ * @param[in] text The message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_set(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t create, time_t lastmod, char *who, char *text, unsigned int flags)
+{
+  char msg[BUFSIZE];                    /* msg for logging */
+  int new = 0;                          /* welcome is new - not set yet */
+
+  /* assert */
+  assert(NULL != cptr);
+  assert(NULL != sptr);
+  assert(WelcomeNameIsValid(nameint));
+  assert(WelcomeArrayIsValid(namearray));
+  assert(lastmod >= 0);
+  assert(lastmod > 0 || flags & WELCOME_FORCE);   /* lastmod must not be 0 unless forced */
+  assert(NULL != who);
+  assert(NULL != text);
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_set(\"%s\", \"%s\", %d, %d, %Tu, %Tu, \"%s\", \"%s\","
+                      "FLAGS(0x%04x): local=%s announce=%s force=%s insert=%s delete=%s)",
+    cli_name(cptr), cli_name(sptr), nameint, namearray, create, lastmod, who, text, flags,
+      (flags & WELCOME_LOCAL) ? "yes" : "no",
+      (flags & WELCOME_ANNOUNCE) ? "yes" : "no",
+      (flags & WELCOME_FORCE) ? "yes" : "no",
+      (flags & WELCOME_INSERT) ? "yes" : "no",
+      (flags & WELCOME_DELETE) ? "yes" : "no"));
+
+  /* not set */
+  if (WelcomeIsEmpty(namearray))
+    new = 1;
+
+  /* update */
+  welcome_make(namearray, text, who, create, lastmod, flags);
+
+  /* create msg for log */
+  ircd_snprintf(0, msg, 0, "%s%s%s WELCOME %d \"%s\" %s [%Tu]",
+    new ? "setting" : "changing",
+    (flags & WELCOME_ANNOUNCE) ? " and announcing " : " ",
+    (flags & WELCOME_LOCAL) ? "local" : "global",
+    nameint, WelcomeText(namearray), WelcomeWho(namearray), create);
+
+  /* log it */
+  welcome_log(sptr, msg, flags);
+
+  /* propagate it */
+  if (!(flags & WELCOME_LOCAL))
+    welcome_propagate(cptr, sptr, nameint, create, lastmod, who, text, flags);
+
+  /* announce it */
+  if (flags & WELCOME_ANNOUNCE)
+    welcome_announce(namearray, flags);
+
+  return 0;
+}
+
+
+/** Unset a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @param[in] who Who set this message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_unset(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t create, time_t lastmod, char *who, unsigned int flags)
+{
+  char msg[BUFSIZE];                    /* msg for logging */
+
+  /* assert */
+  assert(NULL != cptr);
+  assert(NULL != sptr);
+  assert(WelcomeNameIsValid(nameint));
+  assert(WelcomeArrayIsValid(namearray));
+  assert(!WelcomeIsEmpty(namearray) || flags & WELCOME_FORCE);   /* must be set unless forced */
+  assert(lastmod >= 0);
+  assert(lastmod > 0 || flags & WELCOME_FORCE);   /* lastmod must not be 0 unless forced */
+  assert(NULL != who);
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_unset(\"%s\", \"%s\", %d, %d, %Tu, %Tu, \"%s\","
+                      "FLAGS(0x%04x): local=%s announce=%s force=%s insert=%s delete=%s)",
+    cli_name(cptr), cli_name(sptr), nameint, namearray, create, lastmod, who, flags,
+      (flags & WELCOME_LOCAL) ? "yes" : "no",
+      (flags & WELCOME_ANNOUNCE) ? "yes" : "no",
+      (flags & WELCOME_FORCE) ? "yes" : "no",
+      (flags & WELCOME_INSERT) ? "yes" : "no",
+      (flags & WELCOME_DELETE) ? "yes" : "no"));
+
+  /* create msg for log */
+  ircd_snprintf(0, msg, 0, "unsetting %s WELCOME %d \"%s\" %s [%Tu]",
+    (flags & WELCOME_LOCAL) ? "local" : "global",
+    nameint, WelcomeText(namearray), WelcomeWho(namearray), create);
+
+  /* log it but only if it was set
+   *  can be a forced unset on a welcome that is not set
+   */
+  if (!WelcomeIsEmpty(namearray))
+    welcome_log(sptr, msg, flags);
+
+  /* update, 
+   *   not when inserting, welcome_insert() handles that
+   *   not when deleting, welcome_delete() handles that
+   */
+  if (!(flags & (WELCOME_INSERT|WELCOME_DELETE)))
+    welcome_make(namearray, "", who, create, lastmod, flags);
+
+  /* propagate it, but not when inserting */
+  if (!(flags & (WELCOME_LOCAL|WELCOME_INSERT)))
+    welcome_propagate(cptr, sptr, nameint, create, lastmod, who, "", flags);
+
+  return 0;
+}
+
+
+/** Insert a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @param[in] who Who set this message.
+ * @param[in] text The welcome message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_insert(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t create, time_t lastmod, char *who, char *text, unsigned int flags)
+{
+  char msg[BUFSIZE];                    /* msg for logging */
+  int i;                                /* loop variable */
+  int empty = -1;                       /* first empty spot in array after namearray */
+  int end = WELCOME_MAX_ENTRIES -1;     /* last element to check in array */
+  int last = end;                       /* last welcome message to feed to welcome_unset */
+
+  /* assert */
+  assert(NULL != cptr);
+  assert(NULL != sptr);
+  assert(WelcomeNameIsValid(nameint));
+  assert(WelcomeArrayIsValid(namearray));
+  assert(lastmod >= 0);
+  assert(lastmod > 0 || flags & WELCOME_FORCE);   /* lastmod must not be 0 unless forced */
+  assert(NULL != who);
+  assert(NULL != text);
+  assert(flags & WELCOME_INSERT);   /* must be insert */
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_insert(\"%s\", \"%s\", %d, %d, %Tu, %Tu, \"%s\", \"%s\","
+                      "FLAGS(0x%04x): local=%s announce=%s force=%s insert=%s delete=%s)",
+    cli_name(cptr), cli_name(sptr), nameint, namearray, create, lastmod, who, text, flags,
+      (flags & WELCOME_LOCAL) ? "yes" : "no",
+      (flags & WELCOME_ANNOUNCE) ? "yes" : "no",
+      (flags & WELCOME_FORCE) ? "yes" : "no",
+      (flags & WELCOME_INSERT) ? "yes" : "no",
+      (flags & WELCOME_DELETE) ? "yes" : "no"));
+
+  /* correct end for local offset */
+  if (flags & WELCOME_LOCAL)
+    end += WELCOME_MAX_ENTRIES;
+
+  /* find first empty spot */
+  for (i = namearray; i <= end; i++) {
+    if (WelcomeIsEmpty(i)) {
+      empty = i;
+      break;
+    }
+  }
+
+  /* no empty spot, need to unset last */
+  if (empty == -1) {
+    welcome_unset(cptr, sptr, end +1, end, create, lastmod, who, flags);
+    empty = end;
+  }
+
+  /* move entries down, update lastmod - lastmod for end is already updated above */
+  for (i = empty; i > namearray; i--)
+    welcome_make(i, WelcomeText(i-1), WelcomeWho(i-1), WelcomeCreate(i-1),
+      lastmod, flags | WELCOME_INCLASTMOD);
+
+  /* correct empty for local offset */
+  if (flags & WELCOME_LOCAL)
+    empty -= WELCOME_MAX_ENTRIES;
+
+  /* create msg for log */
+  if (nameint == empty)
+    ircd_snprintf(0, msg, 0, "moving %s WELCOME message %d one place down",
+      (flags & WELCOME_LOCAL) ? "local" : "global", nameint);  
+  else 
+    ircd_snprintf(0, msg, 0, "moving %s WELCOME message %d %s %d one place down",
+      (flags & WELCOME_LOCAL) ? "local" : "global", nameint, (empty - nameint > 1) ? "to" : "and" , empty);
+
+  /* log it */
+  welcome_log(sptr, msg, flags);
+
+  /* set it */
+  welcome_set(cptr, sptr, nameint, namearray, create, lastmod, who, text, flags);
+
+  return 0;
+}
+
+
+/** Delete a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @param[in] who Who set this message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_delete(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t create, time_t lastmod, char *who, unsigned int flags)
+{
+  int i;                                /* loop variable */
+  int empty = namearray;                /* first empty spot in array after namearray */
+  int end = WELCOME_MAX_ENTRIES -1;     /* last element to check in array */ 
+
+  /* assert */
+  assert(NULL != cptr);
+  assert(NULL != sptr);
+  assert(WelcomeNameIsValid(nameint));
+  assert(WelcomeArrayIsValid(namearray));
+  assert(lastmod >= 0);
+  assert(lastmod > 0 || flags & WELCOME_FORCE);   /* lastmod must not be 0 unless forced */
+  assert(NULL != who);
+  assert(flags & WELCOME_DELETE);   /* must be delete */
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_delete(\"%s\", \"%s\", %d, %d, %Tu, %Tu, \"%s\","
+                      "FLAGS(0x%04x): local=%s announce=%s force=%s insert=%s delete=%s)",
+    cli_name(cptr), cli_name(sptr), nameint, namearray, create, lastmod, who, flags,
+      (flags & WELCOME_LOCAL) ? "yes" : "no",
+      (flags & WELCOME_ANNOUNCE) ? "yes" : "no",
+      (flags & WELCOME_FORCE) ? "yes" : "no",
+      (flags & WELCOME_INSERT) ? "yes" : "no",
+      (flags & WELCOME_DELETE) ? "yes" : "no"));
+
+  /* unset it */
+  welcome_unset(cptr, sptr, nameint, namearray, create, lastmod, who, flags);
+
+  /* correct end for local offset */
+  if (flags & WELCOME_LOCAL)
+    end += WELCOME_MAX_ENTRIES;
+
+  /* move entries up, update lastmod */
+  for (i = namearray; i < end; i++) {
+    if (!WelcomeIsSet(i+1))
+      break;
+    welcome_make(i, WelcomeText(i+1), WelcomeWho(i+1), WelcomeCreate(i+1),
+      lastmod, flags | WELCOME_INCLASTMOD);
+  }
+
+  /* clear last entry */
+  if (i == end)
+    welcome_make(i, "", who, create, lastmod, flags | WELCOME_INCLASTMOD);
+
+  /* nothing was moved, clear entry */
+  if (i == namearray)
+    welcome_make(i, "", who, create, lastmod, flags);
+
+  return 0;
+}
+
+
+/** Change a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] name Name of the message.
+ * @param[in] create When it was set.
+ * @param[in] lastmod Last modification timestamp.
+ * @param[in] who Who set this message.
+ * @param[in] text The welcome message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_do(struct Client *cptr, struct Client *sptr, char *name,
+  time_t create, time_t lastmod, char *who, char *text, unsigned int flags)
+{
+  int nameint = atoi(name);                /* transform to int */
+  int namearray = nameint - 1;             /* used to test the array element */
+
+  /* assert */
+  assert(NULL != cptr);
+  assert(NULL != sptr);
+  assert(NULL != name);
+  assert(NULL != text);
+  assert(NULL != who);
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_do(\"%s\", \"%s\", \"%s\", %Tu, %Tu, \"%s\", \"%s\","
+                      "FLAGS(0x%04x): local=%s announce=%s force=%s insert=%s delete=%s)",
+    cli_name(cptr), cli_name(sptr), name, create, lastmod, who, text, flags,
+      (flags & WELCOME_LOCAL) ? "yes" : "no",
+      (flags & WELCOME_ANNOUNCE) ? "yes" : "no",
+      (flags & WELCOME_FORCE) ? "yes" : "no",
+      (flags & WELCOME_INSERT) ? "yes" : "no",
+      (flags & WELCOME_DELETE) ? "yes" : "no"));
+
+  /* name empty after taking off the prefixes? */
+  if (*name == 0) {
+    if (IsUser(sptr))
+      sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :Welcome: No message number given", sptr);
+    else 
+      protocol_violation(cptr, "Received WELCOME with no message number from %C", sptr);
+    return 0;
+  }
+
+  /* check name */
+  if (!WelcomeArrayIsValid(namearray)) {
+    if (IsUser(sptr))
+      sendcmdto_one(&me, CMD_NOTICE, sptr,
+        "%C :Welcome: Invalid message number %s - should between 1 and %d",
+        sptr, name, WELCOME_MAX_ENTRIES);
+    else
+      protocol_violation(cptr,
+        "Received WELCOME with invalid message number %s from %C - should be between 1 and %d",
+        name, sptr, WELCOME_MAX_ENTRIES);
+    return 0;
+  }
+
+  /* invalid lastmod */
+  if (lastmod <= 0) {
+    /* from my user - must be a glitch,
+     *   someone set (my) network time to 0 ?
+     */
+    if (MyUser(sptr))
+      lastmod = 1;
+    /* not forced or negative, it is a protocol violation */
+    else if (!(flags & WELCOME_FORCE) || lastmod < 0)
+      return protocol_violation(cptr, "Received WELCOME with invalid lastmod timestamp %Tu from %C", lastmod, sptr);
+  }
+
+  /* source is user, and is myuser or welcome is local, check length of the message */
+  if (IsUser(sptr) && (MyConnect(sptr) || (flags & WELCOME_LOCAL)) && (strlen(text) > WELCOMELEN)) {
+    sendcmdto_one(&me, CMD_NOTICE, sptr,
+      "%C :Welcome: The message is too long with %d chars - max is %d chars",
+      sptr, strlen(text), WELCOMELEN);
+    ircd_strncpy(text, text, WELCOMELEN);
+    sendcmdto_one(&me, CMD_NOTICE, sptr,
+      "%C :Welcome: Change or truncate the message to: \"%s\"", sptr, text);
+    return 0;
+  }
+
+  /* correct namearray for local offset */
+  if (flags & WELCOME_LOCAL)
+    namearray += WELCOME_MAX_ENTRIES;
+
+  /* must be true by now */
+  assert(WelcomeArrayIsValid(namearray));
+  assert(WelcomeNameIsValid(nameint));
+
+  /* cannot unset welcome that is not set */
+  if (!WelcomeIsSet(namearray) && *text == 0) {
+
+    /* from user, throw error */
+    if (IsUser(sptr))
+      return send_reply(sptr, ERR_NOSUCHWELCOME, name);
+
+     /* new local welcome from server, but empty - ignore
+      * we do accept a new global welcome message that is empty 
+      */
+    if (flags & WELCOME_LOCAL)
+      return 0;
+  }
+
+  /* check if there is something to change */
+  /* we got a record for it */
+  if (WelcomeIsSet(namearray)) {
+
+    /* global and not forced */
+    if (!(flags & (WELCOME_LOCAL|WELCOME_FORCE))) {
+
+      /* myuser changes it,
+       *   WelcomeLastMod greater than or equal to lastmod, take WelcomeLastMod+1 as lastmod
+       *   else the change is not accepted upstream because of the older TS
+       */
+      if (MyUser(sptr)) {
+        if (WelcomeLastMod(namearray) >= lastmod)
+          lastmod = WelcomeLastMod(namearray) +1;
+      }
+
+      /* compare lastmod, ignore welcome when:
+       *   we got a newer one
+       *   or when lastmod is the same and our text is 'smaller'
+       */
+      else if ((lastmod < WelcomeLastMod(namearray)) ||            /* we got a newer one */
+              ((lastmod == WelcomeLastMod(namearray)) &&           /* same lastmod */
+               (strcmp(WelcomeText(namearray), text) < 0))) {      /* our text is 'smaller' */
+        /* burst or burst ack, cptr gets our version from the burst */
+        if (IsBurstOrBurstAck(cptr))
+          return 0;
+        /* sync server */
+        return welcome_resend(cptr, nameint, namearray, flags);
+      }
+
+    /* local welcome - we use our idea of the time */
+    } else if (flags & WELCOME_LOCAL) {
+      create = TStime();
+      lastmod = TStime();
+    }
+
+    /* new global welcome from my user or local welcome
+     *   compare new message with old message
+     */
+    if (IsUser(sptr) && (MyConnect(sptr) || (flags & WELCOME_LOCAL))) {
+      if (strcmp(text, WelcomeText(namearray)) == 0) {   /* use strcmp instead of ircd_strcmp - oper may wish to change case */
+        sendcmdto_one(&me, CMD_NOTICE, sptr,
+          "%C :Welcome: Cannot change %s message for %s - nothing to change",
+          sptr, (flags & WELCOME_LOCAL) ? "local" : "global", name); 
+        return 0;
+      }
+    }
+  }
+
+  /* do not insert for last global/local entry and when not set yet */
+  if ((flags & WELCOME_INSERT) &&
+      ((!WelcomeIsSet(namearray)) || (nameint == WELCOME_MAX_ENTRIES)))
+    flags &= ~WELCOME_INSERT;
+
+  /* unset */
+  if (*text == 0) {
+
+    /* clear insert flag,
+     *   when this flag is set, welcome_unset() assumes it is being called from welcome_insert()
+     *   and wont propagate the change
+     *   welcome_delete() calls welcome_unset()
+     */
+    flags &= ~WELCOME_INSERT;
+
+    /* delete */
+    if (flags & WELCOME_DELETE)
+      return welcome_delete(cptr, sptr, nameint, namearray, create, lastmod, who, flags);
+
+    /* unset */
+    return welcome_unset(cptr, sptr, nameint, namearray, create, lastmod, who, flags);
+  }
+
+  /* insert */
+  if (flags & WELCOME_INSERT)
+    return welcome_insert(cptr, sptr, nameint, namearray, create, lastmod, who, text, flags);
+
+  /* new or change */
+  return welcome_set(cptr, sptr, nameint, namearray, create, lastmod, who, text, flags);
+}
+
+
+/** Send the full list of welcome message to \a cptr.
+ * @param[in] cptr Local server to send welcomes to.
+ */
+void
+welcome_burst(struct Client *cptr)
+{
+  int name;                 /* loop variable */
+
+  /* assert */
+  assert(NULL != cptr);
+
+  /* loop over global entries - 0 to max - 1 */
+  for (name = 0; name <= WELCOME_MAX_ENTRIES - 1; name++) {
+    if (WelcomeIsSet(name))
+      sendcmdto_one(&me, CMD_WELCOME, cptr, "* %d %Tu %Tu %s :%s",
+        name + 1,
+        WelcomeCreate(name), WelcomeLastMod(name),
+        WelcomeWho(name), WelcomeText(name));
+  }
+}
+
+
+/** List welcome messages.
+ * @param[in] sptr Client requesting the listing.
+ * @param[in] connect When non zero do not report no welcome is set
+ * @return Zero.
+ */
+int
+welcome_list(struct Client *sptr, int connect)
+{
+  int name;                 /* loop variable */
+  int found = 0;            /* number of welcome messages set */
+  int local = 0;            /* welcome is local or global */
+
+  /* assert */
+  assert(NULL != sptr);
+
+  /* loop over all entries - range 0 to 2 * max - 1 */
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* local entries now */
+    if (name == WELCOME_MAX_ENTRIES)
+      local = 1;
+
+    /* not set or empty - skip */
+    if (!WelcomeIsSet(name) || WelcomeIsEmpty(name))
+      continue;
+
+    /* got one */
+    found++;
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :[%s] %s",
+      sptr, local ? cli_name(&me) : feature_str(FEAT_NETWORK), WelcomeText(name));
+  }
+
+  /* nothing set */
+  if (!found && !connect)
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :No welcome message set.", sptr);
+  
+  return 0;
+}
+
+
+/** Statistics callback to list Welcome messages.
+ * @param[in] sptr Client requesting statistics.
+ * @param[in] sd Stats descriptor for request (ignored).
+ * @param[in] param Extra parameter from user (ignored).
+ */
+void
+welcome_stats(struct Client *sptr, const struct StatDesc *sd, char *param)
+{
+  int name;                 /* loop variable */
+  int local = 0;            /* welcome is local or global */
+
+  /* assert */
+  assert(NULL != sptr);
+
+  /* stats header */
+  send_reply(sptr, SND_EXPLICIT | RPL_STATSWELCOME,
+    "W # Target Who Created LastMod Text");
+
+  /* loop over all entries - range 0 to 2 * max - 1 */
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* local entries now */
+    if (name == WELCOME_MAX_ENTRIES)
+      local = 1;
+
+    /* not set */
+    if (!WelcomeIsSet(name))
+      continue;
+
+    /* send it */
+    send_reply(sptr, RPL_STATSWELCOME,
+      local ? name + 1 - WELCOME_MAX_ENTRIES : name + 1,
+      local ? cli_name(&me) : "*",
+      WelcomeWho(name),
+      WelcomeCreate(name), WelcomeLastMod(name),
+      WelcomeIsEmpty(name) ? "<Empty>" : WelcomeText(name));
+  }
+}
+
+
+/** Count welcome messages and memory used by them.
+ * @param[out] we_size Receives total number of bytes allocated for welcomes.
+ * @return Number of welcome messages currently allocated.
+ */
+int
+welcome_memory_count(size_t *we_size)
+{
+  int name;                 /* loop variable */
+  unsigned int we = 0;      /* number of welcome messages set */
+
+  /* loop over all entries - range 0 to 2 * max - 1 */
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* not set */
+    if (!WelcomeIsSet(name))
+      continue;
+
+    /* count */
+    we++;
+    *we_size += WelcomeText(name) ? (strlen(WelcomeText(name)) + 1) : 0;
+    *we_size += WelcomeWho(name) ? (strlen(WelcomeWho(name)) + 1) : 0;
+  }
+  return we;
+}

Add welcome message functionality.

client commands:
user:
/WELCOME
shows welcome messages set, same is shown on connect

oper:
/WELCOME [<target>] [[!]<name> :<message>]
to view welcome messages from a remote server
to set a local welcome message on this server or a remote server
set a global welcome message (target *)
the ! prefix makes the server annouce the welcome message to its clients when setting

server:
:<source> WE <target> [[!]<name> <timestamp> <who> :<text>]
who is who set the message, the server puts in the opername when a client sets it.
:<name> is a number 1 to WELCOME_MAX_ENTRIES - currently set at 10 (should be more than we ever need)
that means there is room for 10 local and 10 global entries

STATS W/welcome (/STATS w/userload made case sensitive)
:server 230 nick W Name Target Who Timestamp :Message
:server 227 nick W 1 * opername 1233072583 :Latest news: testing this welcome patch :)
:server 227 nick W 2 * opername 1233072583 :
:server 227 nick W 1 servername opername 1233072590 :This is a test server, expect restarts.
:server 219 nick W :End of /STATS report

listing welcomes or on connect:
:server NOTICE nick :[QuakeNet] Latest news: testing this welcome patch :)
:server NOTICE nick :[server] This is a test server, expect restarts.

announcement is done by a notice by the local server to $* with the same message
format as for listing welcome messages.
:server NOTICE $* :[QuakeNet] Latest news: testing this welcome patch :)
:server NOTICE $* :[server] This is a test server, expect restarts.


Files:

include/handlers.h
add m_welcome mo_welcome ms_welcome mh_welcome functions

include/features.h
ircd/features.c
add features FEAT_WELCOME and FEAT_HIS_STATS_W

include/msg.h
add MSG_WELCOME TOK_WELCOME CMD_WELCOME

ircd/parse.c
add welcome message functions

include/numeric.h
ircd/s_err.c
add RPL_STATSWELCOME ERR_NOSUCHWELCOME

include/welcome.h
ircd/welcome.c
ircd/m_welcome.c
new

ircd/Makefile.in
add welcome.c and m_welcome.c files

ircd/s_serv.c
add burst welcome message

ircd/s_stats.c
add /STATS W/welcome

ircd/s_user.c
add showing of welcome messages on connect

diff -r ed0f71fe7e22 include/handlers.h
--- a/include/handlers.h	Wed Jan 28 14:01:58 2009 +0100
+++ b/include/handlers.h	Wed Jan 28 15:15:51 2009 +0100
@@ -151,6 +151,7 @@
 extern int m_version(struct Client*, struct Client*, int, char*[]);
 extern int m_wallchops(struct Client*, struct Client*, int, char*[]);
 extern int m_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int m_welcome(struct Client*, struct Client*, int, char*[]);
 extern int m_who(struct Client*, struct Client*, int, char*[]);
 extern int m_whois(struct Client*, struct Client*, int, char*[]);
 extern int m_whowas(struct Client*, struct Client*, int, char*[]);
@@ -185,6 +186,7 @@
 extern int mo_version(struct Client*, struct Client*, int, char*[]);
 extern int mo_wallops(struct Client*, struct Client*, int, char*[]);
 extern int mo_wallusers(struct Client*, struct Client*, int, char*[]);
+extern int mo_welcome(struct Client*, struct Client*, int, char*[]);
 extern int mr_error(struct Client*, struct Client*, int, char*[]);
 extern int mr_error(struct Client*, struct Client*, int, char*[]);
 extern int mr_pong(struct Client*, struct Client*, int, char*[]);
@@ -242,6 +244,7 @@
 extern int ms_wallops(struct Client*, struct Client*, int, char*[]);
 extern int ms_wallusers(struct Client*, struct Client*, int, char*[]);
 extern int ms_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int ms_welcome(struct Client*, struct Client*, int, char*[]);
 extern int ms_whois(struct Client*, struct Client*, int, char*[]);
 
 extern int mh_nohelp(struct Client*, struct Client*, int, char*[]);
@@ -308,6 +311,7 @@
 extern int mh_wallops(struct Client*, struct Client*, int, char*[]);
 extern int mh_wallusers(struct Client*, struct Client*, int, char*[]);
 extern int mh_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int mh_welcome(struct Client*, struct Client*, int, char*[]);
 extern int mh_who(struct Client*, struct Client*, int, char*[]);
 extern int mh_whois(struct Client*, struct Client*, int, char*[]);
 extern int mh_whowas(struct Client*, struct Client*, int, char*[]);
diff -r ed0f71fe7e22 include/ircd_features.h
--- a/include/ircd_features.h	Wed Jan 28 14:01:58 2009 +0100
+++ b/include/ircd_features.h	Wed Jan 28 15:15:51 2009 +0100
@@ -101,6 +101,7 @@
   FEAT_IRCD_RES_TIMEOUT,
   FEAT_AUTH_TIMEOUT,
   FEAT_ANNOUNCE_INVITES,
+  FEAT_WELCOME,
 
   /* features that affect all operators */
   FEAT_EXTENDED_CHECKCMD,
@@ -143,6 +144,7 @@
   FEAT_HIS_STATS_u,
   FEAT_HIS_STATS_U,
   FEAT_HIS_STATS_v,
+  FEAT_HIS_STATS_W,
   FEAT_HIS_STATS_w,
   FEAT_HIS_STATS_x,
   FEAT_HIS_STATS_y,
diff -r ed0f71fe7e22 include/msg.h
--- a/include/msg.h	Wed Jan 28 14:01:58 2009 +0100
+++ b/include/msg.h	Wed Jan 28 15:15:51 2009 +0100
@@ -195,6 +195,10 @@
 #define MSG_NOTICE              "NOTICE"        /* NOTI */
 #define TOK_NOTICE              "O"
 #define CMD_NOTICE		MSG_NOTICE, TOK_NOTICE
+
+#define MSG_WELCOME             "WELCOME"       /* WELC */
+#define TOK_WELCOME             "WE"
+#define CMD_WELCOME		MSG_WELCOME, TOK_WELCOME
 
 #define MSG_WALLCHOPS           "WALLCHOPS"     /* WC */
 #define TOK_WALLCHOPS           "WC"
diff -r ed0f71fe7e22 include/numeric.h
--- a/include/numeric.h	Wed Jan 28 14:01:58 2009 +0100
+++ b/include/numeric.h	Wed Jan 28 15:15:51 2009 +0100
@@ -116,6 +116,7 @@
 	RPL_STATSGLINE	     227	   Dalnet 
 	RPL_STATSVLINE	     227	   unreal */
 #define RPL_STATSALINE       226        /* Hybrid, Undernet */
+#define RPL_STATSWELCOME     227        /* QuakeNet extension */
 #define RPL_STATSQLINE       228        /* Undernet extension */
 #define RPL_STATSHEADER      230        /* QuakeNet extension */
 
@@ -445,6 +446,8 @@
 /*      ERR_GHOSTEDCLIENT    503           efnet */
 /*	ERR_VWORLDWARN	     503	   austnet */
 
+#define ERR_NOSUCHWELCOME    509        /* QuakeNet extension */
+
 #define ERR_SILELISTFULL     511        /* Undernet extension */
 /*      ERR_NOTIFYFULL       512           aircd */
 /*	ERR_TOOMANYWATCH     512           Numeric List: Dalnet */
diff -r ed0f71fe7e22 include/welcome.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/include/welcome.h	Wed Jan 28 15:15:51 2009 +0100
@@ -0,0 +1,56 @@
+#ifndef INCLUDED_welcome_h
+#define INCLUDED_welcome_h
+/*
+ * IRC - Internet Relay Chat, include/welcome.h
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ * Copyright (C) 2000 Kevin L. Mitchell <klmitch@mit.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/** @file
+ * @brief  Interface and declarations for welcome message handling.
+ */
+#ifndef INCLUDED_sys_types_h
+#include <sys/types.h>
+#define INCLUDED_sys_types_h
+#endif
+
+struct Client;
+struct StatDesc;
+
+/* Maximum number of welcome entries (per type; X global, X local) */
+#define WELCOME_MAX_ENTRIES  10 
+
+/* Describes a Welcome message entry. */
+struct Welcome {
+  char               text[TOPICLEN];   /**< Message */
+  char               who[ACCOUNTLEN];  /**< Who set it */
+  time_t             timestamp;        /**< Timestamp of the welcome */
+};
+
+/** Welcome type flags */
+#define WELCOME_LOCAL    0x01 /**< welcome is local */
+/** Welcome action flags */
+#define WELCOME_ANNOUNCE 0x02 /**< announce change to users */
+
+extern int welcome_do(struct Client *cptr, struct Client *sptr, char *name, char *text,
+  char *who, time_t timestamp, unsigned int flags);
+extern void welcome_announce(int name);
+extern void welcome_burst(struct Client *cptr);
+extern int welcome_list(struct Client *sptr, int connect);
+extern void welcome_stats(struct Client *sptr, const struct StatDesc *sd, char *param);
+
+#endif /* INCLUDED_welcome_h */
\ No newline at end of file
diff -r ed0f71fe7e22 ircd/Makefile.in
--- a/ircd/Makefile.in	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/Makefile.in	Wed Jan 28 15:15:51 2009 +0100
@@ -187,6 +187,7 @@
 	m_wallops.c \
 	m_wallusers.c \
 	m_wallvoices.c \
+	m_welcome.c \
 	m_who.c \
 	m_whois.c \
 	m_whowas.c \
@@ -214,6 +215,7 @@
 	send.c \
 	uping.c \
 	userload.c \
+	welcome.c \
 	whocmds.c \
 	whowas.c \
 	y.tab.c
@@ -1168,6 +1170,11 @@
   ../include/ircd_reply.h ../include/ircd_string.h \
   ../include/ircd_chattr.h ../include/msg.h ../include/numeric.h \
   ../include/numnicks.h ../include/s_user.h ../include/send.h
+m_welcome.o: m_welcome.c ../config.h ../include/channel.h \
+  ../include/client.h ../include/hash.h ../include/ircd.h ../include/ircd_log.h \
+  ../include/ircd_reply.h ../include/ircd_string.h ../include/msg.h \
+  ../include/numeric.h ../include/numnicks.h ../include/s_user.h \
+  ../include/send.h ../include/welcome.h
 m_who.o: m_who.c ../config.h ../include/channel.h ../include/ircd_defs.h \
   ../include/res.h ../config.h ../include/client.h ../include/dbuf.h \
   ../include/msgq.h ../include/ircd_events.h ../include/ircd_handler.h \
@@ -1429,6 +1436,13 @@
   ../include/numnicks.h ../include/querycmds.h ../include/ircd_features.h \
   ../include/s_misc.h ../include/s_stats.h ../include/send.h \
   ../include/struct.h ../include/sys.h
+welcome.o: welcome.c ../config.h ../include/client.h \
+  ../include/hash.h ../include/ircd.h ../include/ircd_alloc.h \
+  ../include/ircd_features.h ../include/ircd_log.h ../include/ircd_reply.h \
+  ../include/match.h ../include/msg.h ../include/numeric.h \
+  ../include/numnicks.h ../include/s_debug.h ../include/s_bsd.h \
+  ../include/s_misc.h ../include/send.h ../include/struct.h \
+  ../include/sys.h ../include/welcome.h
 whocmds.o: whocmds.c ../config.h ../include/whocmds.h \
   ../include/channel.h ../include/ircd_defs.h ../include/res.h \
   ../config.h ../include/client.h ../include/dbuf.h ../include/msgq.h \
diff -r ed0f71fe7e22 ircd/ircd_features.c
--- a/ircd/ircd_features.c	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/ircd_features.c	Wed Jan 28 15:15:51 2009 +0100
@@ -355,6 +355,7 @@
   F_I(IRCD_RES_TIMEOUT, 0, 4, 0),
   F_I(AUTH_TIMEOUT, 0, 9, 0),
   F_B(ANNOUNCE_INVITES, 0, 0, 0),
+  F_B(WELCOME, 0, 1, 0),
 
   /* features that affect all operators */
   F_B(EXTENDED_CHECKCMD, 0, 0, 0),
@@ -397,6 +398,7 @@
   F_B(HIS_STATS_u, 0, 1, 0),
   F_B(HIS_STATS_U, 0, 1, 0),
   F_B(HIS_STATS_v, 0, 1, 0),
+  F_B(HIS_STATS_W, 0, 1, 0),
   F_B(HIS_STATS_w, 0, 1, 0),
   F_B(HIS_STATS_x, 0, 1, 0),
   F_B(HIS_STATS_y, 0, 1, 0),
diff -r ed0f71fe7e22 ircd/m_welcome.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/ircd/m_welcome.c	Wed Jan 28 15:15:51 2009 +0100
@@ -0,0 +1,269 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_welcome.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+#include "config.h"
+
+#include "channel.h"
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "s_user.h"
+#include "send.h"
+#include "welcome.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+
+/*
+ * m_welcome - local generic message handler
+ *
+ * parv[0] = Send prefix
+ */
+int m_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  /* feature disabled */
+  if (!feature_bool(FEAT_WELCOME))
+    return send_reply(sptr, ERR_DISABLED, "WELCOME");
+  return welcome_list(sptr, 0);
+}
+
+
+/*
+ * mo_welcome - oper message handler
+ *
+ * listing:
+ * parv[0] = Send prefix
+ *
+ * remote listing:
+ * parv[0] = Send prefix
+ * parv[1] = Target
+ *
+ * set global or on remote server:
+ * parv[0] = Send prefix
+ * parv[1] = Target: server or * for global
+ * parv[2] = Name
+ * parv[3] = Text
+ */
+int mo_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target, *name, *who, *text, pattern[BUFSIZE];
+  time_t timestamp;
+  unsigned int flags = 0;
+  int local = 0; /* 1 when it is for me */
+
+  /* feature disabled */
+  if (!feature_bool(FEAT_WELCOME))
+    return send_reply(sptr, ERR_DISABLED, "WELCOME");
+
+  /* listing */
+  if (parc < 2)
+    return welcome_list(sptr, 0);
+
+  /* TODO: add PRIV_WELCOME? */
+  /* check PRIVS */
+  if (!HasPriv(sptr,PRIV_SERVERINFO))
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* remote listing request, see if it is for me or a remote server */
+  if (parc == 2) {
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C", 1, parc, parv) != HUNTED_ISME)
+      return 0;
+    return welcome_list(sptr, 0);
+  }
+  
+  /* set the parameters */
+  /* less than 4 parameters, assume target was left out, making it local for me */
+  if (parc < 4) {
+    local++;
+    target = cli_name(&me);
+    name = parv[1];
+    flags |= WELCOME_LOCAL;
+  } else { /* otherwise set as it should */
+    target = parv[1];
+    name = parv[2];
+  }
+  timestamp = TStime();
+  who = cli_user(sptr)->opername;
+  text = parv[parc - 1];
+
+  /* target is not global */
+  if (!(target[0] == '*' && target[1] == '\0') && !local) {
+    /* build a pattern for hunt_server_cmd since we do not have all we need in parv */
+    ircd_snprintf(0, pattern, sizeof(pattern), "%s %s %Tu %s :%s", "%C", name, timestamp, who, text);
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, pattern, 1, 2, parv) != HUNTED_ISME)
+      return 0;
+    flags |= WELCOME_LOCAL; /* local welcome, for me */
+  }
+
+  /* TODO: disallow global announcement from oper?
+   * as PRIVMSG/NOTICE to $* is not allowed either by the ircd
+   * when PRIV for that is added, use that here? PRIV_BROADCAST or something
+   */
+  /* check for anounce prefix */
+  if (*name == '!') {
+     name++;
+     flags |= WELCOME_ANNOUNCE;
+  }
+  
+  /* and do it */
+  return welcome_do(cptr, sptr, name, text, who, timestamp, flags);
+}
+
+
+/*
+ * ms_welcome - server message handler
+ *
+ * parv[0] = Send prefix
+ * parv[1] = Target: server numeric or * for global
+ * parv[2] = Name
+ * parv[3] = Timestamp
+ * parv[4] = Who
+ * parv[5] = Text
+ */
+int ms_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target, *name, *who, *text;
+  time_t timestamp;
+  unsigned int flags = 0;
+  
+  /* not enough */
+  if (parc < 2)
+    return need_more_params(sptr, "WELCOME");
+
+  /* remote listing request, see if it is for me or a remote server */
+  if (parc == 2) {
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C", 1, parc, parv) == HUNTED_ISME)
+      return welcome_list(sptr, 0);
+  }
+
+  /* we need at least 6 parameters to continue */  
+  if (parc < 6)
+    return need_more_params(sptr, "WELCOME");
+
+  /* set the parameters */
+  target = parv[1];
+  name = parv[2];
+  timestamp = atoi(parv[3]);
+  who = parv[4];
+  text = parv[parc - 1];
+
+  /* target is not global */
+  if (!(target[0] == '*' && target[1] == '\0')) {
+    /* not for me, and forward it */
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C %s %s %s :%s", 1, parc, parv) != HUNTED_ISME)
+      return 0;
+    flags |= WELCOME_LOCAL; /* local welcome, for me */
+  }
+
+  /* check for anounce prefix */
+  if (*name == '!') {
+     name++;
+     flags |= WELCOME_ANNOUNCE;
+  }
+
+  /* and do it */
+  return welcome_do(cptr, sptr, name, text, who, timestamp, flags);
+}
+
+
+/*
+ * mh_welcome - help message handler
+ */
+int mh_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  if (!IsAnOper(sptr)) {
+    send_reply(sptr, SND_EXPLICIT | RPL_HELP,
+      "WELCOME :WELCOME");
+    send_reply(sptr, SND_EXPLICIT | RPL_HELP,
+      "WELCOME :Shows welcome messages set on the server.");  
+  } else {
+    send_reply(sptr, SND_EXPLICIT | RPL_HELP,
+      "WELCOME :WELCOME [<target>] [[!]<name> :<message>]");
+    send_reply(sptr, SND_EXPLICIT | RPL_HELP,
+      "WELCOME :Shows or sets welcome messages on a server.");
+  }
+  return 0;
+}
diff -r ed0f71fe7e22 ircd/parse.c
--- a/ircd/parse.c	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/parse.c	Wed Jan 28 15:15:51 2009 +0100
@@ -667,6 +667,15 @@
     /* UNREG, CLIENT, SERVER, OPER, SERVICE, HELP */
     { m_unregistered, m_not_oper, ms_opkick, mo_opkick, m_ignore, mh_nohelp }
   },
+  
+  /* add command for WELCOME */
+  {
+    MSG_WELCOME,
+    TOK_WELCOME,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE, HELP */
+    { m_unregistered, m_welcome, ms_welcome, mo_welcome, m_ignore, mh_welcome }
+  },
 
   /* This command is an alias for QUIT during the unregistered part of
    * of the server.  This is because someone jumping via a broken web
diff -r ed0f71fe7e22 ircd/s_err.c
--- a/ircd/s_err.c	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/s_err.c	Wed Jan 28 15:15:51 2009 +0100
@@ -486,7 +486,7 @@
 /* 226 */
   { RPL_STATSALINE, "%s", "226" },
 /* 227 */
-  { 0 },
+  { RPL_STATSWELCOME, "W %d %s %s %Tu :%s", "227" },
 /* 228 */
   { RPL_STATSQLINE, "Q %s :%s", "228" },
 /* 229 */
@@ -1050,7 +1050,7 @@
 /* 508 */
   { 0 },
 /* 509 */
-  { 0 },
+  { ERR_NOSUCHWELCOME, "%s :No such welcome", "509" },
 /* 510 */
   { 0 },
 /* 511 */
diff -r ed0f71fe7e22 ircd/s_serv.c
--- a/ircd/s_serv.c	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/s_serv.c	Wed Jan 28 15:15:51 2009 +0100
@@ -57,6 +57,7 @@
 #include "struct.h"
 #include "sys.h"
 #include "userload.h"
+#include "welcome.h"
 
 /* #include <assert.h> -- Now using assert in ircd_log.h */
 #include <stdlib.h>
@@ -196,6 +197,7 @@
    */
   gline_burst(cptr);
   jupe_burst(cptr);
+  welcome_burst(cptr);
 
   /*
    * Pass on my client information to the new server
diff -r ed0f71fe7e22 ircd/s_stats.c
--- a/ircd/s_stats.c	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/s_stats.c	Wed Jan 28 15:15:51 2009 +0100
@@ -54,6 +54,7 @@
 #include "send.h"
 #include "struct.h"
 #include "userload.h"
+#include "welcome.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -689,9 +690,12 @@
   { 'V', "vserversmach", (STAT_FLAG_OPERFEAT | STAT_FLAG_VARPARAM | STAT_FLAG_CASESENS), FEAT_HIS_STATS_v,
     stats_servers_verbose, 0,
     "Verbose server information." },
-  { 'w', "userload", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_w,
+  { 'w', "userload", STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS, FEAT_HIS_STATS_w,
     calc_load, 0,
     "Userload statistics." },
+  { 'W', "welcome", STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS, FEAT_HIS_STATS_W,
+    welcome_stats, 0,
+    "Welcome messages." },
   { 'x', "memusage", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_x,
     stats_meminfo, 0,
     "List usage information." },
diff -r ed0f71fe7e22 ircd/s_user.c
--- a/ircd/s_user.c	Wed Jan 28 14:01:58 2009 +0100
+++ b/ircd/s_user.c	Wed Jan 28 15:15:51 2009 +0100
@@ -63,6 +63,7 @@
 #include "userload.h"
 #include "version.h"
 #include "whowas.h"
+#include "welcome.h"
 
 #include "handlers.h" /* m_motd and m_lusers */
 
@@ -411,6 +412,9 @@
                            cli_info(sptr), NumNick(cptr) /* two %s's */);
 
     IPcheck_connect_succeeded(sptr);
+
+    if (feature_bool(FEAT_WELCOME))
+      welcome_list(sptr, 1);
   }
   else {
     struct Client *acptr = user->server;
diff -r ed0f71fe7e22 ircd/welcome.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/ircd/welcome.c	Wed Jan 28 15:15:51 2009 +0100
@@ -0,0 +1,355 @@
+/*
+ * IRC - Internet Relay Chat, ircd/welcome.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Finland
+ * Copyright (C) 2000 Kevin L. Mitchell <klmitch@mit.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/** @file
+ * @brief Implementation of welcome message handling functions.
+ */
+#include "config.h"
+
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_alloc.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "match.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "s_bsd.h"
+#include "s_debug.h"
+#include "s_misc.h"
+#include "send.h"
+#include "struct.h"
+#include "sys.h"    /* FALSE bleah */
+#include "welcome.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+#include <string.h>
+
+
+/** List of welcome messages - first MAX for global, second MAX for local */
+static struct Welcome WelcomeArray[WELCOME_MAX_ENTRIES * 2]; 
+
+
+
+/** Allocate a new welcome with the given parameters.
+ * @param[in] name Name of the welcome message.
+ * @param[in] text The welcome message.
+ * @param[in] who Who set it.
+ * @param[in] timestamp When it was set.
+ * @return name Array number of the welcome set.
+ */
+static int 
+welcome_make(int name, char *text, char *who, time_t timestamp)
+{
+  /* range 0 to 2 * max - 1 */
+  assert(name >= 0 && name <= 2 * WELCOME_MAX_ENTRIES - 1);
+
+  /* store it */
+  ircd_strncpy(WelcomeArray[name].text, text, TOPICLEN);
+  ircd_strncpy(WelcomeArray[name].who, who, ACCOUNTLEN);
+  WelcomeArray[name].timestamp = timestamp;
+
+  return name;
+}
+
+
+/** Change a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] name Name of the message.
+ * @param[in] text The welcome message.
+ * @param[in] timestamp Timestamp of when the message was set.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_do(struct Client *cptr, struct Client *sptr, char *name, char *text,
+  char *who, time_t timestamp, unsigned int flags)
+{
+  int nameint = atoi(name);                /* transform to int */
+  int namearray = nameint - 1;             /* used to test the array element */
+  int notext = (text[0] == '\0') ? 1 : 0;  /* 1 when text is empty */
+  char *action;                            /* used for logging */
+  /* TODO: these needed? */
+  /*
+  who[ACCOUNTLEN-1] = 0;
+  text[WELCOMELEN-1] = 0;
+  */
+
+  /* TODO: NULL or 0 ? they are pointers, so NULL? */
+  assert(0 != cptr);
+  assert(0 != sptr);
+  assert(0 != name);
+  /* TODO: assert(0 != text); */
+  assert(0 != who);
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_do(\"%s\", \"%s\", \"%s\", \"%s\" \"%s\", %Tu, 0x%04x)",
+   cli_name(cptr), cli_name(sptr), name, text, who, timestamp, flags));
+
+  /* check name */
+  if (nameint < 1 || nameint > WELCOME_MAX_ENTRIES) {
+    if (IsUser(sptr))
+      sendcmdto_one(&me, CMD_NOTICE, sptr,
+        "%C :WELCOME: Invalid message number %s - should between 1 and %d",
+        sptr, name, WELCOME_MAX_ENTRIES); 
+    return 0;
+  }
+
+  /* correct namearray for local offset */
+  if (flags & WELCOME_LOCAL)
+    namearray += WELCOME_MAX_ENTRIES;
+
+  /* cannot unset welcome that is not set */
+  if (WelcomeArray[namearray].timestamp == 0 && notext) {
+    /* from user, throw error */
+    if (IsUser(sptr))
+      return send_reply(sptr, ERR_NOSUCHWELCOME, name);
+     /* new local welcome from server, but empty - ignore */
+    if (flags & WELCOME_LOCAL)
+      return 0;
+    /* new global welcome message, but empty, accept from server
+     * otherwise we do not have the same state as them
+     */
+  }
+
+  /* TODO: check if we receive an entry with a timestamp >> TStime()
+   * ..so from the future
+   * something is wrong there - either side is wrong about the time (or both)
+   *
+   * if we accept a global welcome message with a timestamp far into the future
+   * it will not be possible to change it - well, not until we pass that point in time
+   * or /settime to get to it, or hack with a service..
+   *
+   * how to handle this - like CREATE and settime? hm, or throw error to ops?
+   */
+  /* check if there is something to change */
+  if (WelcomeArray[namearray].timestamp != 0) { /* we got a record for it */
+    if (namearray < WELCOME_MAX_ENTRIES) { /* global */
+      if (timestamp == WelcomeArray[namearray].timestamp) /* we got this version already */
+        return 0;
+      if (timestamp < WelcomeArray[namearray].timestamp) { /* we got a later version */
+        if (IsBurstOrBurstAck(cptr)) /* middle of a burst, it will resync on its own */
+          return 0;
+        return welcome_resend(cptr, namearray); /* resync the server */
+      }
+    } else
+      /* local welcome, set timestamp to nettime, accept any change
+       * we parse local welcome messages in the order we receive them
+       * they cannot cross on the network and are not bursted,
+       * and thus timestamp is not required for conflict resolving.
+       */
+      timestamp = TStime();
+
+    /* compare new message with old message */
+    if (ircd_strcmp(text, WelcomeArray[namearray].text) == 0) {
+      if (IsUser(sptr))
+        sendcmdto_one(&me, CMD_NOTICE, sptr,
+          "%C :WELCOME: Cannot change %smessage for %s - nothing to change.",
+          sptr, (flags & WELCOME_LOCAL) ? "local " : "", name); 
+      return 0;
+    }
+  }
+
+  /* update */
+  welcome_make(namearray, text, who, timestamp);
+
+  /* set action */
+  if (flags & WELCOME_LOCAL)
+    action = notext ? "removing local" : "changing local";
+  else
+    action = notext ? "unsetting" : "changing";
+
+  /* TODO: WALLOPS for local welcome messages, so that all operators know about it? */
+  /* inform ops */
+  sendto_opmask_butone(0, SNO_OLDSNO, "%s %s WELCOME for %d%s%s",
+    (feature_bool(FEAT_HIS_SNOTICES) || IsServer(sptr)) ?
+    get_client_name_and_opername(sptr) : cli_name((cli_user(sptr))->server),
+    action, nameint, notext ? "" : " to :", notext ? "" : WelcomeArray[namearray].text);
+
+  /* log it */
+  log_write(LS_NETWORK, L_INFO, LOG_NOSNOTICE, "%#C (%s) %s WELCOME for %d%s%s [%Tu]",
+    sptr, WelcomeArray[namearray].who, action, nameint,
+    notext ? "" : " to :", notext ? "" : WelcomeArray[namearray].text,
+    WelcomeArray[namearray].timestamp);
+
+  /* TODO: or WALLOPS here, local message remotely set? */
+  /* welcome set by remote user, inform oper of success */
+  if ((flags & WELCOME_LOCAL) && IsUser(sptr) && !MyUser(sptr))
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :%s %s WELCOME for %d%s%s",
+      sptr, get_client_name_and_opername(sptr), action, nameint,
+      notext ? "" : " to :", notext ? "" : WelcomeArray[namearray].text);
+
+  /* propagate it */
+  if (!(flags & WELCOME_LOCAL))
+    sendcmdto_serv_butone(sptr, CMD_WELCOME, cptr, "* %s%d %Tu %s :%s",
+      (flags & WELCOME_ANNOUNCE) ? "!" : "", nameint,
+      WelcomeArray[namearray].timestamp, WelcomeArray[namearray].who,
+      WelcomeArray[namearray].text);
+
+  /* announce it */
+  if ((flags & WELCOME_ANNOUNCE) && !notext)
+    welcome_announce(namearray);
+
+  return 0;
+}
+
+
+/** Announce a welcome message to local clients.
+ * @param[in] name Welcome message to announce.
+ */
+void
+welcome_announce(int name)
+{
+  struct Client *acptr;
+  struct MsgBuf *msgbuf;
+
+  /* range 0 to 2 * max - 1 */
+  assert(name >= 0 && name <= 2 * WELCOME_MAX_ENTRIES - 1); 
+
+  /* TODO: target is $* as if it were a global broadcast
+   * could make it $servername for local message announcement
+   * but the type is shown between [ ] already
+   * either [Network] or [servername] - using $* is just shorter.
+   */
+  /* build msgbuf */
+  msgbuf = msgq_make(0, ":%C %s $* :[%s] %s", &me, MSG_NOTICE,
+    name >= WELCOME_MAX_ENTRIES ? cli_name(&me) : feature_str(FEAT_NETWORK),
+    WelcomeArray[name].text);
+
+  /* go over clients */
+  for (acptr = GlobalClientList; acptr; acptr = cli_next(acptr)) {
+
+    /* skip remote users
+     * skip unregistered clients - they see the message during login
+     */
+    if (!MyUser(acptr) || !IsRegistered(acptr))
+      continue;
+
+    /* send it away */
+    send_buffer(acptr, msgbuf, 0);
+  }
+}
+
+
+/** Send the full list of welcome message to \a cptr.
+ * @param[in] cptr Local server to send welcomes to.
+ */
+void
+welcome_burst(struct Client *cptr)
+{
+  int name;
+
+  /* loop over global entries - 0 to max - 1*/
+  for (name = 0; name <= WELCOME_MAX_ENTRIES - 1; name++) {
+    if (WelcomeArray[name].timestamp != 0)
+      sendcmdto_one(&me, CMD_WELCOME, cptr, "* %d %Tu %s :%s",
+        name + 1, WelcomeArray[name].timestamp, WelcomeArray[name].who,
+        WelcomeArray[name].text);
+  }
+}
+
+
+/** Forward a welcome to another server.
+ * @param[in] cptr %Server to send welcome to.
+ * @param[in] welcome Welcome to forward.
+ */
+int
+welcome_resend(struct Client *cptr, int name)
+{
+  sendcmdto_one(&me, CMD_WELCOME, cptr, "* %d %Tu %s :%s",
+    name + 1, WelcomeArray[name].timestamp, WelcomeArray[name].who,
+    WelcomeArray[name].text);
+  return 0;
+}
+
+
+/** List welcome messages.
+ * @param[in] sptr Client requesting the listing.
+ * @param[in] connect When non zero do not report no welcome is set
+ * @return Zero.
+ */
+int
+welcome_list(struct Client *sptr, int connect)
+{
+  int found = 0, local = 0, name;
+
+  /* loop over all entries - range 0 to 2 * max - 1 */
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* local entries now */
+    if (name == WELCOME_MAX_ENTRIES)
+      local = 1;
+
+    /* not set or empty - skip */
+    if (WelcomeArray[name].timestamp == 0 || *WelcomeArray[name].text == 0)
+      continue;
+
+    /* got one */
+    found++;
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :[%s] %s",
+      sptr, local ? cli_name(&me) : feature_str(FEAT_NETWORK), WelcomeArray[name].text);
+  }
+
+  /* nothing set */
+  if (!found && !connect)
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :No welcome message set.", sptr);
+  
+  return 0;
+}
+
+
+/** Statistics callback to list Welcome messages.
+ * @param[in] sptr Client requesting statistics.
+ * @param[in] sd Stats descriptor for request (ignored).
+ * @param[in] param Extra parameter from user (ignored).
+ */
+void
+welcome_stats(struct Client *sptr, const struct StatDesc *sd, char *param)
+{
+  int name, local = 0;
+
+  /* TODO: change "Who" to "Opername" or "OperID" as that is what it is? */
+  /* send header so the client knows what we are showing */
+  send_reply(sptr, SND_EXPLICIT | RPL_STATSHEADER,
+    "W Name Target Who Timestamp :Message");
+
+  /* loop over all entries - range 0 to 2 * max - 1*/
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* local entries now */
+    if (name == WELCOME_MAX_ENTRIES)
+      local = 1;
+
+    /* not set */
+    if (WelcomeArray[name].timestamp == 0)
+      continue;
+
+    /* send it */
+    send_reply(sptr, RPL_STATSWELCOME,
+      local ? name + 1 - WELCOME_MAX_ENTRIES : name + 1, local ? cli_name(&me) : "*",
+      WelcomeArray[name].who, WelcomeArray[name].timestamp,
+      (*WelcomeArray[name].text == 0) ? "<Empty>" : WelcomeArray[name].text);
+  }
+}

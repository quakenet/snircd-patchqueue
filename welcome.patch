Add welcome message functionality.

client commands:
user:
/WELCOME
shows welcome messages set, same is shown on connect

oper:
/WELCOME [<target>] [[!]<name> :<message>]
to view welcome messages from a remote server
to set a local welcome message on this server or a remote server
set a global welcome message (target *)
the ! prefix makes the server annouce the welcome message to its clients when setting

server:
:<source> WE <target> [[!]<name> <timestamp> <who> :<text>]
who is who set the message, the server puts in the opername when a client sets it.
:<name> is a number 1 to WELCOME_MAX_ENTRIES - currently set at 10 (should be more than we ever need)
that means there is room for 10 local and 10 global entries

STATS W/welcome (/STATS w/userload made case sensitive)
:server 230 nick W Name Target Who Timestamp :Message
:server 227 nick W 1 * opername 1233072583 :Latest news: testing this welcome patch :)
:server 227 nick W 2 * opername 1233072583 :
:server 227 nick W 1 servername opername 1233072590 :This is a test server, expect restarts.
:server 219 nick W :End of /STATS report

listing welcomes or on connect:
:server NOTICE nick :[QuakeNet] Latest news: testing this welcome patch :)
:server NOTICE nick :[server] This is a test server, expect restarts.

announcement is done by a notice by the local server to $* with the same message
format as for listing welcome messages.
:server NOTICE $* :[QuakeNet] Latest news: testing this welcome patch :)
:server NOTICE $* :[server] This is a test server, expect restarts.


Files:

include/handlers.h
add m_welcome mo_welcome ms_welcome mh_welcome functions

include/features.h
ircd/features.c
add features FEAT_WELCOME and FEAT_HIS_STATS_W

include/msg.h
add MSG_WELCOME TOK_WELCOME CMD_WELCOME

ircd/parse.c
add welcome message functions

include/numeric.h
ircd/s_err.c
add RPL_STATSWELCOME ERR_NOSUCHWELCOME

include/welcome.h
ircd/welcome.c
ircd/m_welcome.c
new

ircd/Makefile.in
add welcome.c and m_welcome.c files

ircd/s_serv.c
add burst welcome message

ircd/s_stats.c
add /STATS W/welcome

ircd/s_user.c
add showing of welcome messages on connect

include/client.h
ircd/client.c
ircd/ircd_lexer.l
ircd/ircd_parser.y
add PRIV_LOCAL_WELCOME PRIV_WELCOME

diff -r 4676d2565f9b include/client.h
--- a/include/client.h
+++ b/include/client.h
@@ -142,6 +142,8 @@
     PRIV_USER_PRIVACY,  /* oper can bypass user privacy +x etc gives i.e. see real ip's */
     PRIV_CHANNEL_PRIVACY, /* oper can bypass channel privacy i.e. can see modes on channels they are not on and channel keys */ 
     PRIV_SERVERINFO,     /* oper can use /get, /stats, /hash, retrieve remote information */
+    PRIV_WELCOME,        /* oper can WELCOME */
+    PRIV_LOCAL_WELCOME,  /* oper can local WELCOME */
     PRIV_LAST_PRIV /**< number of privileges */
   };
 
diff -r 4676d2565f9b include/handlers.h
--- a/include/handlers.h
+++ b/include/handlers.h
@@ -138,6 +138,7 @@
 extern int m_version(struct Client*, struct Client*, int, char*[]);
 extern int m_wallchops(struct Client*, struct Client*, int, char*[]);
 extern int m_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int m_welcome(struct Client*, struct Client*, int, char*[]);
 extern int m_who(struct Client*, struct Client*, int, char*[]);
 extern int m_whois(struct Client*, struct Client*, int, char*[]);
 extern int m_whowas(struct Client*, struct Client*, int, char*[]);
@@ -172,6 +173,7 @@
 extern int mo_version(struct Client*, struct Client*, int, char*[]);
 extern int mo_wallops(struct Client*, struct Client*, int, char*[]);
 extern int mo_wallusers(struct Client*, struct Client*, int, char*[]);
+extern int mo_welcome(struct Client*, struct Client*, int, char*[]);
 extern int mo_xquery(struct Client*, struct Client*, int, char*[]);
 extern int mr_error(struct Client*, struct Client*, int, char*[]);
 extern int mr_error(struct Client*, struct Client*, int, char*[]);
@@ -230,6 +232,7 @@
 extern int ms_wallops(struct Client*, struct Client*, int, char*[]);
 extern int ms_wallusers(struct Client*, struct Client*, int, char*[]);
 extern int ms_wallvoices(struct Client*, struct Client*, int, char*[]);
+extern int ms_welcome(struct Client*, struct Client*, int, char*[]);
 extern int ms_whois(struct Client*, struct Client*, int, char*[]);
 extern int ms_xquery(struct Client*, struct Client*, int, char*[]);
 extern int ms_xreply(struct Client*, struct Client*, int, char*[]);
diff -r 4676d2565f9b include/ircd_features.h
--- a/include/ircd_features.h
+++ b/include/ircd_features.h
@@ -101,6 +101,7 @@
   FEAT_IRCD_RES_TIMEOUT,
   FEAT_AUTH_TIMEOUT,
   FEAT_ANNOUNCE_INVITES,
+  FEAT_WELCOME,
 
   /* features that affect all operators */
   FEAT_EXTENDED_CHECKCMD,
@@ -142,6 +143,7 @@
   FEAT_HIS_STATS_u,
   FEAT_HIS_STATS_U,
   FEAT_HIS_STATS_v,
+  FEAT_HIS_STATS_W,
   FEAT_HIS_STATS_w,
   FEAT_HIS_STATS_x,
   FEAT_HIS_STATS_y,
diff -r 4676d2565f9b include/msg.h
--- a/include/msg.h
+++ b/include/msg.h
@@ -196,6 +196,10 @@
 #define TOK_NOTICE              "O"
 #define CMD_NOTICE		MSG_NOTICE, TOK_NOTICE
 
+#define MSG_WELCOME             "WELCOME"       /* WELC */
+#define TOK_WELCOME             "WE"
+#define CMD_WELCOME		MSG_WELCOME, TOK_WELCOME
+
 #define MSG_WALLCHOPS           "WALLCHOPS"     /* WC */
 #define TOK_WALLCHOPS           "WC"
 #define CMD_WALLCHOPS		MSG_WALLCHOPS, TOK_WALLCHOPS
diff -r 4676d2565f9b include/numeric.h
--- a/include/numeric.h
+++ b/include/numeric.h
@@ -116,6 +116,7 @@
 	RPL_STATSGLINE	     227	   Dalnet 
 	RPL_STATSVLINE	     227	   unreal */
 #define RPL_STATSALINE       226        /* Hybrid, Undernet */
+#define RPL_STATSWELCOME     227        /* QuakeNet extension */
 #define RPL_STATSQLINE       228        /* Undernet extension */
 
 /*      RPL_SERVICEINFO      231	unused */
@@ -440,6 +441,8 @@
 /*      ERR_GHOSTEDCLIENT    503           efnet */
 /*	ERR_VWORLDWARN	     503	   austnet */
 
+#define ERR_NOSUCHWELCOME    509        /* QuakeNet extension */
+
 #define ERR_SILELISTFULL     511        /* Undernet extension */
 /*      ERR_NOTIFYFULL       512           aircd */
 /*	ERR_TOOMANYWATCH     512           Numeric List: Dalnet */
diff -r 4676d2565f9b include/welcome.h
--- /dev/null
+++ b/include/welcome.h
@@ -0,0 +1,63 @@
+#ifndef INCLUDED_welcome_h
+#define INCLUDED_welcome_h
+/*
+ * IRC - Internet Relay Chat, include/welcome.h
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ * Copyright (C) 2000 Kevin L. Mitchell <klmitch@mit.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/** @file
+ * @brief  Interface and declarations for welcome message handling.
+ */
+#ifndef INCLUDED_sys_types_h
+#include <sys/types.h>
+#define INCLUDED_sys_types_h
+#endif
+
+struct Client;
+struct StatDesc;
+
+/* Maximum number of welcome entries (per type; X global, X local) */
+#define WELCOME_MAX_ENTRIES  10
+/* Maximum length of a welcome message */
+#define WELCOMELEN TOPICLEN
+/* Maximum timestamp drift in seconds allowed ahead of our idea of nettime
+ * before we throw a warning to ops
+ */
+#define WELCOME_MAX_DRIFT   600
+
+/* Describes a Welcome message entry. */
+struct Welcome {
+  time_t             timestamp;            /**< Timestamp of the welcome */
+  char               text[WELCOMELEN + 1]; /**< Message */
+  char               who[ACCOUNTLEN + 1];  /**< Who set it */
+};
+
+/** Welcome type flags */
+#define WELCOME_LOCAL    0x01 /**< welcome is local */
+/** Welcome action flags */
+#define WELCOME_ANNOUNCE 0x02 /**< announce change to users */
+#define WELCOME_INSERT   0x04 /**< insert welcome message, move down all others one place */
+
+extern int welcome_do(struct Client *cptr, struct Client *sptr, char *name,
+  time_t timestamp, char *who, char *text, unsigned int flags);
+extern void welcome_announce(int name);
+extern void welcome_burst(struct Client *cptr);
+extern int welcome_list(struct Client *sptr, int connect);
+extern void welcome_stats(struct Client *sptr, const struct StatDesc *sd, char *param);
+
+#endif /* INCLUDED_welcome_h */
diff -r 4676d2565f9b ircd/Makefile.in
--- a/ircd/Makefile.in
+++ b/ircd/Makefile.in
@@ -186,6 +186,7 @@
 	m_wallops.c \
 	m_wallusers.c \
 	m_wallvoices.c \
+	m_welcome.c \
 	m_who.c \
 	m_whois.c \
 	m_whowas.c \
@@ -215,6 +216,7 @@
 	send.c \
 	uping.c \
 	userload.c \
+	welcome.c \
 	whocmds.c \
 	whowas.c \
 	y.tab.c
@@ -1161,6 +1163,11 @@
   ../include/ircd_reply.h ../include/ircd_string.h \
   ../include/ircd_chattr.h ../include/msg.h ../include/numeric.h \
   ../include/numnicks.h ../include/s_user.h ../include/send.h
+m_welcome.o: m_welcome.c ../config.h ../include/channel.h \
+  ../include/client.h ../include/hash.h ../include/ircd.h ../include/ircd_log.h \
+  ../include/ircd_reply.h ../include/ircd_string.h ../include/msg.h \
+  ../include/numeric.h ../include/numnicks.h ../include/s_user.h \
+  ../include/send.h ../include/welcome.h
 m_who.o: m_who.c ../config.h ../include/channel.h ../include/ircd_defs.h \
   ../include/res.h ../config.h ../include/client.h ../include/dbuf.h \
   ../include/msgq.h ../include/ircd_events.h ../include/ircd_handler.h \
@@ -1422,6 +1429,13 @@
   ../include/numnicks.h ../include/querycmds.h ../include/ircd_features.h \
   ../include/s_misc.h ../include/s_stats.h ../include/send.h \
   ../include/struct.h ../include/sys.h
+welcome.o: welcome.c ../config.h ../include/client.h \
+  ../include/hash.h ../include/ircd.h ../include/ircd_alloc.h \
+  ../include/ircd_features.h ../include/ircd_log.h ../include/ircd_reply.h \
+  ../include/match.h ../include/msg.h ../include/numeric.h \
+  ../include/numnicks.h ../include/s_debug.h ../include/s_bsd.h \
+  ../include/s_misc.h ../include/send.h ../include/struct.h \
+  ../include/sys.h ../include/welcome.h
 whocmds.o: whocmds.c ../config.h ../include/whocmds.h \
   ../include/channel.h ../include/ircd_defs.h ../include/res.h \
   ../config.h ../include/client.h ../include/dbuf.h ../include/msgq.h \
diff -r 4676d2565f9b ircd/client.c
--- a/ircd/client.c
+++ b/ircd/client.c
@@ -177,6 +177,7 @@
     FlagSet(&privs_local, PRIV_WHOX);
     FlagSet(&privs_local, PRIV_DISPLAY);
     FlagSet(&privs_local, PRIV_FORCE_LOCAL_OPMODE);
+    FlagSet(&privs_local, PRIV_LOCAL_WELCOME);
 
     privs_defaults_set = 1;
   }
@@ -223,6 +224,7 @@
     ClrPriv(client, PRIV_JUPE);
     ClrPriv(client, PRIV_OPMODE);
     ClrPriv(client, PRIV_BADCHAN);
+    ClrPriv(client, PRIV_WELCOME);
   }
 }
 
@@ -244,7 +246,7 @@
   P(CHANSERV),       P(XTRA_OPER),      P(NOIDLE),        P(FREEFORM),
   P(PARANOID),       P(CHECK),          P(WALL),          P(CLOSE),
   P(ROUTE),          P(ROUTEINFO),      P(SERVERINFO),    P(CHANNEL_PRIVACY),
-  P(USER_PRIVACY),
+  P(USER_PRIVACY),   P(WELCOME),        P(LOCAL_WELCOME),
 #undef P
   { 0, 0 }
 };
diff -r 4676d2565f9b ircd/ircd_features.c
--- a/ircd/ircd_features.c
+++ b/ircd/ircd_features.c
@@ -366,6 +366,7 @@
   F_I(IRCD_RES_TIMEOUT, 0, 4, 0),
   F_I(AUTH_TIMEOUT, 0, 9, 0),
   F_B(ANNOUNCE_INVITES, 0, 0, 0),
+  F_B(WELCOME, 0, 1, 0),
 
   /* features that affect all operators */
   F_B(EXTENDED_CHECKCMD, 0, 0, 0),
@@ -407,6 +408,7 @@
   F_B(HIS_STATS_u, 0, 1, 0),
   F_B(HIS_STATS_U, 0, 1, 0),
   F_B(HIS_STATS_v, 0, 1, 0),
+  F_B(HIS_STATS_W, 0, 1, 0),
   F_B(HIS_STATS_w, 0, 1, 0),
   F_B(HIS_STATS_x, 0, 1, 0),
   F_B(HIS_STATS_y, 0, 1, 0),
diff -r 4676d2565f9b ircd/ircd_lexer.l
--- a/ircd/ircd_lexer.l
+++ b/ircd/ircd_lexer.l
@@ -166,6 +166,8 @@
   { "serverinfo", TPRIV_SERVERINFO },
   { "user_privacy", TPRIV_USER_PRIVACY },
   { "channel_privacy", TPRIV_CHANNEL_PRIVACY },
+  { "local_welcome", TPRIV_LOCAL_WELCOME },
+  { "welcome", TPRIV_WELCOME },
   { NULL, 0 }
 };
 static int ntokens;
diff -r 4676d2565f9b ircd/ircd_parser.y
--- a/ircd/ircd_parser.y
+++ b/ircd/ircd_parser.y
@@ -189,6 +189,7 @@
 %token TPRIV_CHANSERV TPRIV_XTRA_OPER TPRIV_NOIDLE TPRIV_FREEFORM TPRIV_PARANOID
 %token TPRIV_CHECK TPRIV_WALL TPRIV_CLOSE TPRIV_ROUTE TPRIV_ROUTEINFO TPRIV_SERVERINFO
 %token TPRIV_CHANNEL_PRIVACY TPRIV_USER_PRIVACY TPRIV_LIST_CHAN 
+%token TPRIV_LOCAL_WELCOME TPRIV_WELCOME
 /* and some types... */
 %type <num> sizespec
 %type <num> timespec timefactor factoredtimes factoredtime
@@ -703,6 +704,8 @@
           TPRIV_SERVERINFO { $$ = PRIV_SERVERINFO ; } |
           TPRIV_CHANNEL_PRIVACY { $$ = PRIV_CHANNEL_PRIVACY ; } |
           TPRIV_USER_PRIVACY { $$ = PRIV_USER_PRIVACY ; } |
+          TPRIV_LOCAL_WELCOME { $$ = PRIV_LOCAL_WELCOME; } |
+          TPRIV_WELCOME { $$ = PRIV_WELCOME; } |
           TPRIV_PARANOID { $$ = PRIV_PARANOID; } ;
 yesorno: YES { $$ = 1; } | NO { $$ = 0; };
 
diff -r 4676d2565f9b ircd/m_welcome.c
--- /dev/null
+++ b/ircd/m_welcome.c
@@ -0,0 +1,296 @@
+/*
+ * IRC - Internet Relay Chat, ircd/m_welcome.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Computing Center
+ *
+ * See file AUTHORS in IRC package for additional names of
+ * the programmers.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ */
+
+/*
+ * m_functions execute protocol messages on this server:
+ *
+ *    cptr    is always NON-NULL, pointing to a *LOCAL* client
+ *            structure (with an open socket connected!). This
+ *            identifies the physical socket where the message
+ *            originated (or which caused the m_function to be
+ *            executed--some m_functions may call others...).
+ *
+ *    sptr    is the source of the message, defined by the
+ *            prefix part of the message if present. If not
+ *            or prefix not found, then sptr==cptr.
+ *
+ *            (!IsServer(cptr)) => (cptr == sptr), because
+ *            prefixes are taken *only* from servers...
+ *
+ *            (IsServer(cptr))
+ *                    (sptr == cptr) => the message didn't
+ *                    have the prefix.
+ *
+ *                    (sptr != cptr && IsServer(sptr) means
+ *                    the prefix specified servername. (?)
+ *
+ *                    (sptr != cptr && !IsServer(sptr) means
+ *                    that message originated from a remote
+ *                    user (not local).
+ *
+ *            combining
+ *
+ *            (!IsServer(sptr)) means that, sptr can safely
+ *            taken as defining the target structure of the
+ *            message in this server.
+ *
+ *    *Always* true (if 'parse' and others are working correct):
+ *
+ *    1)      sptr->from == cptr  (note: cptr->from == cptr)
+ *
+ *    2)      MyConnect(sptr) <=> sptr == cptr (e.g. sptr
+ *            *cannot* be a local connection, unless it's
+ *            actually cptr!). [MyConnect(x) should probably
+ *            be defined as (x == x->from) --msa ]
+ *
+ *    parc    number of variable parameter strings (if zero,
+ *            parv is allowed to be NULL)
+ *
+ *    parv    a NULL terminated list of parameter pointers,
+ *
+ *                    parv[0], sender (prefix string), if not present
+ *                            this points to an empty string.
+ *                    parv[1]...parv[parc-1]
+ *                            pointers to additional parameters
+ *                    parv[parc] == NULL, *always*
+ *
+ *            note:   it is guaranteed that parv[0]..parv[parc-1] are all
+ *                    non-NULL pointers.
+ */
+#include "config.h"
+
+#include "channel.h"
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_snprintf.h"
+#include "ircd_string.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "s_user.h"
+#include "send.h"
+#include "welcome.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+
+/*
+ * m_welcome - local generic message handler
+ *
+ * parv[0] = Send prefix
+ * parv[1] = [remote server to query]
+ */
+int m_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  /* feature disabled */
+  if (!feature_bool(FEAT_WELCOME))
+    return send_reply(sptr, ERR_DISABLED, "WELCOME");
+
+  /* only opers can set the welcome messages */
+  if (parc > 2)
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* remote listing request, see if it is for me or a remote server
+   *  check FEAT_HIS_REMOTE to decide if an ordinary user can do this
+   */
+  if ((parc > 1) && (hunt_server_cmd(sptr, CMD_WELCOME, cptr, feature_int(FEAT_HIS_REMOTE),
+        "%C", 1, parc, parv) != HUNTED_ISME))
+    return 0;
+
+  /* local listing */
+  return welcome_list(sptr, 0);
+}
+
+
+/*
+ * mo_welcome - oper message handler
+ *
+ * listing:
+ * parv[0] = Send prefix
+ *
+ * remote listing:
+ * parv[0] = Send prefix
+ * parv[1] = Target
+ *
+ * set global or on remote server:
+ * parv[0] = Send prefix
+ * parv[1] = Target: server or * for global (or left out for this server)
+ * parv[2] = Name
+ * parv[3] = Text
+ */
+int mo_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target, *name, *who, *text, pattern[BUFSIZE];
+  time_t timestamp;
+  unsigned int flags = 0;
+  int local = 0;
+
+  /* feature disabled */
+  if (!feature_bool(FEAT_WELCOME))
+    return send_reply(sptr, ERR_DISABLED, "WELCOME");
+
+  /* TODO: move feature check here? */
+  /* remote listing request, see if it is for me or a remote server */
+  if ((parc == 2) && (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C", 1, parc, parv) != HUNTED_ISME))
+    return 0;
+
+  /* local listing */
+  if (parc <= 2)
+    return welcome_list(sptr, 0);
+
+  /* check PRIVS */
+  /* local - need PRIV LOCAL_WELCOME or WELCOME */
+  if (parc == 3 && !HasPriv(sptr,PRIV_LOCAL_WELCOME) && !HasPriv(sptr,PRIV_WELCOME))
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* global or remote - need PRIV WELCOME */
+  if (parc >= 4 && !HasPriv(sptr,PRIV_WELCOME))
+    return send_reply(sptr, ERR_NOPRIVILEGES);
+
+  /* set the parameters */
+
+  /* target not given, only name - setting local welcome */
+  if (parc < 4) {
+    local++;
+    target = cli_name(&me);
+    name = parv[1];
+    flags |= WELCOME_LOCAL;
+
+  /* target and name given */
+  } else {
+    target = parv[1];
+    name = parv[2];
+  }
+  timestamp = TStime();
+  who = cli_user(sptr)->opername;
+  text = parv[parc - 1];
+
+  /* target is not global */
+  if (!(target[0] == '*' && target[1] == '\0') && !local) {
+
+    /* build a pattern for hunt_server_cmd since we do not have all we need in parv */
+    ircd_snprintf(0, pattern, sizeof(pattern), "%s %s %Tu %s :%s", "%C", name, timestamp, who, text);
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, pattern, 1, 2, parv) != HUNTED_ISME)
+      return 0;
+
+   /* else it is a local welcome, for me */
+    flags |= WELCOME_LOCAL; 
+  }
+
+  /* TODO: disallow global announcement from oper?
+   * as PRIVMSG/NOTICE to $* is not allowed either by the ircd
+   * when PRIV for that is added, use that here? PRIV_BROADCAST or something
+   *
+   * change prefix to $ ?
+   */
+  /* check for anounce prefix */
+  if (*name == '!') {
+     name++;
+     flags |= WELCOME_ANNOUNCE;
+  }
+
+  /* check for insert prefix */
+  if (*name == '+') {
+     name++;
+     flags |= WELCOME_INSERT;
+  }
+
+  /* and do it */
+  return welcome_do(cptr, sptr, name, timestamp, who, text, flags);
+}
+
+
+/*
+ * ms_welcome - server message handler
+ *
+ * parv[0] = Send prefix
+ * parv[1] = Target: server numeric or * for global
+ * parv[2] = Name
+ * parv[3] = Timestamp
+ * parv[4] = Who
+ * parv[5] = Text
+ */
+int ms_welcome(struct Client* cptr, struct Client* sptr, int parc, char* parv[])
+{
+  char *target, *name, *who, *text;
+  time_t timestamp;
+  unsigned int flags = 0;
+  
+  /* not enough - complain */
+  if (parc < 2) {
+    protocol_violation(sptr, "Too few parameters for WELCOME (got %d - need 2)", parc);
+    return need_more_params(sptr, "WELCOME");
+  }
+
+  /* remote listing request, see if it is for me or a remote server */
+  if (parc == 2) {
+    if (IsServer(sptr))
+      return protocol_violation(cptr, "WELCOME listing request from server %C", sptr);
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C", 1, parc, parv) != HUNTED_ISME)
+      return 0;
+    return welcome_list(sptr, 0);
+  }
+
+  /* we need at least 6 parameters to continue - complain */  
+  if (parc < 6) {
+    protocol_violation(sptr, "Too few parameters for WELCOME (got %d - need 6)", parc);
+    return need_more_params(sptr, "WELCOME");
+  }
+
+  /* set the parameters */
+  target = parv[1];
+  name = parv[2];
+  timestamp = atoi(parv[3]);
+  who = parv[4];
+  text = parv[parc - 1]; /* parse reason as last parameter */
+
+  /* target is not global */
+  if (!(target[0] == '*' && target[1] == '\0')) {
+
+    /* not for me, and forward it */
+    if (hunt_server_cmd(sptr, CMD_WELCOME, cptr, 0, "%C %s %s %s :%s", 1, parc, parv) != HUNTED_ISME)
+      return 0;
+
+    /* local welcome for me */
+    flags |= WELCOME_LOCAL; 
+  }
+
+  /* check for anounce prefix */
+  if (*name == '!') {
+     name++;
+     flags |= WELCOME_ANNOUNCE;
+  }
+
+  /* check for insert prefix */
+  if (*name == '+') {
+     name++;
+     flags |= WELCOME_INSERT;
+  }
+
+  /* and do it */
+  return welcome_do(cptr, sptr, name, timestamp, who, text, flags);
+}
diff -r 4676d2565f9b ircd/parse.c
--- a/ircd/parse.c
+++ b/ircd/parse.c
@@ -661,6 +661,15 @@
     /* UNREG, CLIENT, SERVER, OPER, SERVICE */
     { m_unregistered, m_not_oper, ms_check, mo_check, m_ignore }
   },
+  
+  /* add command for WELCOME */
+  {
+    MSG_WELCOME,
+    TOK_WELCOME,
+    0, MAXPARA, MFLG_SLOW, 0, NULL,
+    /* UNREG, CLIENT, SERVER, OPER, SERVICE, HELP */
+    { m_unregistered, m_welcome, ms_welcome, mo_welcome, m_ignore }
+  },
 
   /* This command is an alias for QUIT during the unregistered part of
    * of the server.  This is because someone jumping via a broken web
diff -r 4676d2565f9b ircd/s_err.c
--- a/ircd/s_err.c
+++ b/ircd/s_err.c
@@ -486,7 +486,7 @@
 /* 226 */
   { RPL_STATSALINE, "%s", "226" },
 /* 227 */
-  { 0 },
+  { RPL_STATSWELCOME, "W %d %s %s %Tu :%s", "227" },
 /* 228 */
   { RPL_STATSQLINE, "Q %s :%s", "228" },
 /* 229 */
@@ -1050,7 +1050,7 @@
 /* 508 */
   { 0 },
 /* 509 */
-  { 0 },
+  { ERR_NOSUCHWELCOME, "%s :No such welcome", "509" },
 /* 510 */
   { 0 },
 /* 511 */
diff -r 4676d2565f9b ircd/s_serv.c
--- a/ircd/s_serv.c
+++ b/ircd/s_serv.c
@@ -57,6 +57,7 @@
 #include "struct.h"
 #include "sys.h"
 #include "userload.h"
+#include "welcome.h"
 
 /* #include <assert.h> -- Now using assert in ircd_log.h */
 #include <stdlib.h>
@@ -196,6 +197,7 @@
    */
   gline_burst(cptr);
   jupe_burst(cptr);
+  welcome_burst(cptr);
 
   /*
    * Pass on my client information to the new server
diff -r 4676d2565f9b ircd/s_stats.c
--- a/ircd/s_stats.c
+++ b/ircd/s_stats.c
@@ -54,6 +54,7 @@
 #include "send.h"
 #include "struct.h"
 #include "userload.h"
+#include "welcome.h"
 
 #include <stdio.h>
 #include <stdlib.h>
@@ -654,9 +655,12 @@
   { 'V', "vserversmach", (STAT_FLAG_OPERFEAT | STAT_FLAG_VARPARAM | STAT_FLAG_CASESENS), FEAT_HIS_STATS_v,
     stats_servers_verbose, 0,
     "Verbose server information." },
-  { 'w', "userload", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_w,
+  { 'w', "userload", STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS, FEAT_HIS_STATS_w,
     calc_load, 0,
     "Userload statistics." },
+  { 'W', "welcome", STAT_FLAG_OPERFEAT | STAT_FLAG_CASESENS, FEAT_HIS_STATS_W,
+    welcome_stats, 0,
+    "Welcome messages." },
   { 'x', "memusage", STAT_FLAG_OPERFEAT, FEAT_HIS_STATS_x,
     stats_meminfo, 0,
     "List usage information." },
diff -r 4676d2565f9b ircd/s_user.c
--- a/ircd/s_user.c
+++ b/ircd/s_user.c
@@ -63,6 +63,7 @@
 #include "userload.h"
 #include "version.h"
 #include "whowas.h"
+#include "welcome.h"
 
 #include "handlers.h" /* m_motd and m_lusers */
 
@@ -410,6 +411,9 @@
                            cli_info(sptr), NumNick(cptr) /* two %s's */);
 
     IPcheck_connect_succeeded(sptr);
+
+    if (feature_bool(FEAT_WELCOME))
+      welcome_list(sptr, 1);
   }
   else {
     struct Client *acptr = user->server;
diff -r 4676d2565f9b ircd/welcome.c
--- /dev/null
+++ b/ircd/welcome.c
@@ -0,0 +1,570 @@
+/*
+ * IRC - Internet Relay Chat, ircd/welcome.c
+ * Copyright (C) 1990 Jarkko Oikarinen and
+ *                    University of Oulu, Finland
+ * Copyright (C) 2000 Kevin L. Mitchell <klmitch@mit.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 1, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+/** @file
+ * @brief Implementation of welcome message handling functions.
+ */
+#include "config.h"
+
+#include "client.h"
+#include "hash.h"
+#include "ircd.h"
+#include "ircd_alloc.h"
+#include "ircd_features.h"
+#include "ircd_log.h"
+#include "ircd_reply.h"
+#include "ircd_string.h"
+#include "match.h"
+#include "msg.h"
+#include "numeric.h"
+#include "numnicks.h"
+#include "s_bsd.h"
+#include "s_debug.h"
+#include "s_misc.h"
+#include "send.h"
+#include "struct.h"
+#include "sys.h"    /* FALSE bleah */
+#include "welcome.h"
+
+/* #include <assert.h> -- Now using assert in ircd_log.h */
+#include <string.h>
+
+
+/** List of welcome messages - first MAX for global, second MAX for local */
+static struct Welcome WelcomeArray[WELCOME_MAX_ENTRIES * 2] = { { 0 } };
+
+
+/** Allocate a new welcome with the given parameters.
+ * @param[in] name Name of the welcome message.
+ * @param[in] text The welcome message.
+ * @param[in] who Who set it.
+ * @param[in] timestamp When it was set.
+ * @return name Array number of the welcome set.
+ */
+static int 
+welcome_make(int name, char *text, char *who, time_t timestamp)
+{
+  /* range 0 to 2 * max - 1 */
+  assert(name >= 0 && name <= 2 * WELCOME_MAX_ENTRIES - 1);
+
+  /* store it */
+  ircd_strncpy(WelcomeArray[name].text, text, WELCOMELEN);
+  ircd_strncpy(WelcomeArray[name].who, who, ACCOUNTLEN);
+  WelcomeArray[name].timestamp = timestamp;
+
+  return name;
+}
+
+
+/** Propagate a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] timestamp Timestamp of when the message was set.
+ * @param[in] who Who set this message.
+ * @param[in] text The welcome message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_propagate(struct Client *cptr, struct Client *sptr, int nameint,
+  time_t timestamp, char *who, char *text, unsigned int flags)
+{
+  assert(!(flags & WELCOME_LOCAL));
+
+  sendcmdto_serv_butone(sptr, CMD_WELCOME, cptr, "* %s%s%d %Tu %s :%s",
+    (flags & WELCOME_ANNOUNCE) ? "!" : "", (flags & WELCOME_INSERT) ? "+" : "",
+    nameint, timestamp, who, text);
+
+  return 0;
+}
+
+
+/** Log a welcome message.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] msg The message to show.
+ * @param[in] who Who set this message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_log(struct Client *sptr, char *msg, char *who, unsigned int flags)
+{
+
+  /* inform ops */
+  sendto_opmask_butone(0, SNO_OLDSNO, "%s %s",
+    (feature_bool(FEAT_HIS_SNOTICES) || IsServer(sptr)) ?
+    get_client_name_and_opername(sptr) : cli_name((cli_user(sptr))->server), msg);
+
+  /* log it */
+  log_write(LS_NETWORK, L_INFO, LOG_NOSNOTICE, "%#C (%s) %s", sptr, who, msg);
+
+  /* welcome by remote user, inform oper of success */
+  if ((flags & WELCOME_LOCAL) && IsUser(sptr) && !MyUser(sptr)) {
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :%s %s",
+      sptr, get_client_name_and_opername(sptr), msg);
+
+    /* TODO: wallops all local changes, by both local and remote opers? */
+    /* tell all opers about the local message being set remotely */
+    sendwallto_group_butone(&me, WALL_WALLOPS, 0, "%s %s", get_client_name_and_opername(sptr), msg);
+  }
+
+  return 0;
+}
+
+
+/** Set a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] timestamp Timestamp of when the message was set.
+ * @param[in] who Who set this message.
+ * @param[in] text The message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_set(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t timestamp, char *who, char *text, unsigned int flags)
+{
+  char msg[BUFSIZE];                    /* msg for snomask, logging, etc. */
+  int new = 0;
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_set(\"%s\", \"%s\", %d, %d, %Tu, \"%s\", \"%s\", 0x%04x)",
+   cli_name(cptr), cli_name(sptr), nameint, namearray, timestamp, who, text, flags));
+
+  /* not set */
+  if (*WelcomeArray[namearray].text == 0)
+    new = 1;
+
+  /* update */
+  welcome_make(namearray, text, who, timestamp);
+
+  /* create msg for snomask, logging, etc. */
+  ircd_snprintf(0, msg, 0, "%s%s%s WELCOME %d \"%s\" [%Tu]",
+    new ? "setting" : "changing",
+    (flags & WELCOME_ANNOUNCE) ? " and announcing " : " ",
+    (flags & WELCOME_LOCAL) ? "local" : "global",
+    nameint, text, timestamp);
+
+  /* log it */
+  welcome_log(sptr, msg, who, flags);
+
+  /* propagate it */
+  if (!(flags & WELCOME_LOCAL))
+    welcome_propagate(cptr, sptr, nameint, timestamp, who, text, flags);
+
+  /* announce it */
+  if (flags & WELCOME_ANNOUNCE)
+    welcome_announce(namearray);
+
+  return 0;
+}
+
+
+/** Unset a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] timestamp Timestamp of when the message was set.
+ * @param[in] who Who set this message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_unset(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t timestamp, char *who, unsigned int flags)
+{
+  char msg[BUFSIZE];                    /* msg for snomask, logging, etc. */
+  char text[WELCOMELEN + 1];         /* save old text */ 
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_unset(\"%s\", \"%s\", %d, %d, %Tu, \"%s\", 0x%04x)",
+   cli_name(cptr), cli_name(sptr), nameint, namearray, timestamp, who, flags));
+
+  /* save text */
+  ircd_strncpy(text, WelcomeArray[namearray].text, WELCOMELEN); 
+
+  /* update */
+  welcome_make(namearray, "", who, timestamp);
+
+  /* create msg for snomask, logging, etc. */
+  ircd_snprintf(0, msg, 0, "unsetting %s WELCOME %d \"%s\" [%Tu]",
+    (flags & WELCOME_LOCAL) ? "local" : "global", nameint, text, timestamp);
+
+  /* log it */
+  welcome_log(sptr, msg, who, flags);
+
+  /* propagate it, but not when inserting */
+  if (!(flags & (WELCOME_LOCAL|WELCOME_INSERT)))
+    welcome_propagate(cptr, sptr, nameint, timestamp, who, "", flags);
+
+  return 0;
+}
+
+
+/** Insert a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] nameint Name of the message.
+ * @param[in] namearray Array entry.
+ * @param[in] timestamp Timestamp of when the message was set.
+ * @param[in] who Who set this message.
+ * @param[in] text The welcome message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_insert(struct Client *cptr, struct Client *sptr, int nameint,
+  int namearray, time_t timestamp, char *who, char *text, unsigned int flags)
+{
+  char msg[BUFSIZE];                    /* msg for snomask, logging, etc. */
+  int i;                                /* loop variable */
+  int empty = -1;                       /* first empty spot in array after arrayname */
+  int end = WELCOME_MAX_ENTRIES -1;     /* last element to check in array */
+  int last = end;                       /* last welcome message to feed to welcome_unset */
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_insert(\"%s\", \"%s\", %d, %d, %Tu, \"%s\", \"%s\", 0x%04x)",
+   cli_name(cptr), cli_name(sptr), nameint, namearray, timestamp, who, text, flags));
+
+  /* not set yet, do not insert */
+  if (WelcomeArray[namearray].timestamp == 0)
+    return 0;
+
+  /* last global entry */
+  if (!(flags & WELCOME_LOCAL) && (nameint == WELCOME_MAX_ENTRIES))
+    return 0;
+
+  /* last local entry */
+  if ((flags & WELCOME_LOCAL) && (nameint == 2 * WELCOME_MAX_ENTRIES)) 
+    return 0;
+
+  /* correct end for local offset */
+  if (flags & WELCOME_LOCAL)
+    end += WELCOME_MAX_ENTRIES;
+
+  /* found first empty spot */
+  for (i = namearray; i <= end; i++) {
+    if (*WelcomeArray[i].text == 0) {
+      empty = i;
+      break;
+    }
+  }
+
+  /* no empty spot, need to unset last */
+  if (empty == -1) {
+    welcome_unset(cptr, sptr, end, namearray, timestamp, who, flags);
+    empty = end;
+  }
+
+  /* move entries down, update timestamp */
+  for (i = empty; i > namearray; i--)
+    welcome_make(i, WelcomeArray[i-1].text, WelcomeArray[i-1].who, timestamp);
+
+  /* correct empty for local offset */
+  if (flags & WELCOME_LOCAL)
+    empty -= WELCOME_MAX_ENTRIES;
+
+  /* create msg for snomask, logging, etc. */
+  if (nameint == empty)
+    ircd_snprintf(0, msg, 0, "moving %s WELCOME message %d one place down",
+      (flags & WELCOME_LOCAL) ? "local" : "global", nameint);  
+  else 
+    ircd_snprintf(0, msg, 0, "moving %s WELCOME message %d %s %d one place down",
+      (flags & WELCOME_LOCAL) ? "local" : "global", nameint, (empty - nameint > 1) ? "to" : "and" , empty);
+
+  /* log it */
+  welcome_log(sptr, msg, who, flags);
+
+  /* set it */
+  welcome_set(cptr, sptr, nameint, namearray, timestamp, who, text, flags);
+
+  return 0;
+}
+
+
+/** Change a welcome message.
+ * @param[in] cptr Local client that sent us the welcome.
+ * @param[in] sptr Originator of the welcome.
+ * @param[in] name Name of the message.
+ * @param[in] timestamp Timestamp of when the message was set.
+ * @param[in] who Who set this message.
+ * @param[in] text The welcome message.
+ * @param[in] flags Flags to set on welcome.
+ * @return Zero
+ */
+int
+welcome_do(struct Client *cptr, struct Client *sptr, char *name,
+  time_t timestamp, char *who, char *text, unsigned int flags)
+{
+  int nameint = atoi(name);                /* transform to int */
+  int namearray = nameint - 1;             /* used to test the array element */
+  static time_t rate;                      /* rate limit snomask message */
+
+  assert(NULL != cptr);
+  assert(NULL != sptr);
+  assert(NULL != name);
+  assert(NULL != text);
+  assert(NULL != who);
+
+  /* debug */
+  Debug((DEBUG_DEBUG, "welcome_do(\"%s\", \"%s\", \"%s\", %Tu, \"%s\", \"%s\", 0x%04x)",
+   cli_name(cptr), cli_name(sptr), name, timestamp, who, text, flags));
+
+  /* name empty after taking off the prefixes? */
+  if (EmptyString(name)) {
+    if (IsUser(sptr))
+      sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :WELCOME: No message number given", sptr);
+    else 
+      protocol_violation(cptr, "WELCOME: No message number given by %C", sptr);
+    return 0;
+  }
+
+  /* check name */
+  if (nameint < 1 || nameint > WELCOME_MAX_ENTRIES) {
+    if (IsUser(sptr))
+      sendcmdto_one(&me, CMD_NOTICE, sptr,
+        "%C :WELCOME: Invalid message number %s - should between 1 and %d",
+        sptr, name, WELCOME_MAX_ENTRIES);
+    else {
+      protocol_violation(cptr, "WELCOME: Invalid message number %s from %C - should be between 1 and %d",
+        name, sptr, WELCOME_MAX_ENTRIES);
+      /* nameint greater than MAX, perhaps we are upgrading, but used extra slots too soon?
+       *   propagate it manually
+       * TODO: cant do announce here?
+       */
+      if (nameint > WELCOME_MAX_ENTRIES && !(flags & WELCOME_LOCAL))
+        welcome_propagate(cptr, sptr, nameint, timestamp, who, text, flags);
+    }
+    return 0;
+  }
+
+  /* correct namearray for local offset */
+  if (flags & WELCOME_LOCAL)
+    namearray += WELCOME_MAX_ENTRIES;
+
+  /* must be true by now */
+  assert(namearray >= 0 && namearray <= 2 * WELCOME_MAX_ENTRIES - 1);
+
+  /* cannot unset welcome that is not set */
+  if (WelcomeArray[namearray].timestamp == 0 && EmptyString(text)) {
+
+    /* from user, throw error */
+    if (IsUser(sptr))
+      return send_reply(sptr, ERR_NOSUCHWELCOME, name);
+
+     /* new local welcome from server, but empty - ignore
+      * we do accept a new global welcome message that is empty 
+      */
+    if (flags & WELCOME_LOCAL)
+      return 0;
+  }
+
+  /* check if there is something to change */
+  /* we got a record for it */
+  if (WelcomeArray[namearray].timestamp != 0) {
+
+    /* global */
+    if (!(flags & WELCOME_LOCAL)) {
+
+      /* netburst and we got the same or a newer one
+       *
+       *   we only use the timestamp for resolving conflicts in net burst
+       *   outside of netburst, we simply parse whatever we get
+       *   this way we will not get stuck with a welcome message set by a server
+       *   running ahead with the time
+       */
+      if (IsBurstOrBurstAck(cptr) && timestamp <= WelcomeArray[namearray].timestamp)
+        return 0;
+
+    /* local welcome - we use our idea of the time */
+    } else
+      timestamp = TStime();
+
+    /* compare new message with old message */
+    if (ircd_strcmp(text, WelcomeArray[namearray].text) == 0) {
+      if (IsUser(sptr))
+        sendcmdto_one(&me, CMD_NOTICE, sptr,
+          "%C :WELCOME: Cannot change %s message for %s - nothing to change.",
+          sptr, (flags & WELCOME_LOCAL) ? "local" : "global", name); 
+      return 0;
+    }
+  }
+
+  /* TODO: rate limited for what? max 10 welcome messages..? */
+  /* possible timestamp drift - warn ops */
+  if (timestamp - TStime() > WELCOME_MAX_DRIFT) {
+    sendto_opmask_butone_ratelimited(0, SNO_NETWORK, &rate,
+      "Possible timestamp drift from %C; timestamp in WELCOME message is %is ahead of time",
+      IsServer(sptr) ? sptr : cli_user(sptr)->server, timestamp - TStime());
+
+    /* warn remote oper too */
+    if (IsUser(sptr))
+      sendcmdto_one(&me, CMD_NOTICE, sptr,
+        "%C :Possible timestamp drift from %C; timestamp in WELCOME message is %is ahead of time",
+        sptr, cli_user(sptr)->server, timestamp - TStime()); 
+  }
+
+  /* unset */
+  if (EmptyString(text)) {
+    flags &= ~WELCOME_INSERT;
+    return welcome_unset(cptr, sptr, nameint, namearray, timestamp, who, flags);
+  }
+
+  /* insert */
+  if (flags & WELCOME_INSERT)
+    return welcome_insert(cptr, sptr, nameint, namearray, timestamp, who, text, flags);
+
+  /* new or change */
+  return welcome_set(cptr, sptr, nameint, namearray, timestamp, who, text, flags);
+}
+
+
+/** Announce a welcome message to local clients.
+ * @param[in] name Welcome message to announce.
+ */
+void
+welcome_announce(int name)
+{
+  struct Client *acptr;
+  struct MsgBuf *msgbuf;
+  int i;
+
+  /* range 0 to 2 * max - 1 */
+  assert(name >= 0 && name <= 2 * WELCOME_MAX_ENTRIES - 1); 
+
+  /* TODO: target is $* as if it were a global broadcast
+   * could make it $servername for local message announcement
+   * but the type is shown between [ ] already
+   * either [Network] or [servername] - using $* is just shorter.
+   */
+  /* build msgbuf */
+  msgbuf = msgq_make(0, ":%C %s $* :[%s] %s", &me, MSG_NOTICE,
+    name >= WELCOME_MAX_ENTRIES ? cli_name(&me) : feature_str(FEAT_NETWORK),
+    WelcomeArray[name].text);
+
+  /* go over local clients */
+  for (i = HighestFd; i > 0; --i) {
+
+    /* skip unregistered clients - they see the message during login
+     * skip servers
+     */
+    if (!(acptr = LocalClientArray[i]) || !IsRegistered(acptr) || IsServer(acptr))
+      continue;
+
+    /* send it away */ 
+    send_buffer(acptr, msgbuf, 0);
+  }
+}
+
+
+/** Send the full list of welcome message to \a cptr.
+ * @param[in] cptr Local server to send welcomes to.
+ */
+void
+welcome_burst(struct Client *cptr)
+{
+  int name;
+
+  assert(NULL != cptr);
+
+  /* loop over global entries - 0 to max - 1*/
+  for (name = 0; name <= WELCOME_MAX_ENTRIES - 1; name++) {
+    if (WelcomeArray[name].timestamp != 0)
+      sendcmdto_one(&me, CMD_WELCOME, cptr, "* %d %Tu %s :%s",
+        name + 1, WelcomeArray[name].timestamp, WelcomeArray[name].who,
+        WelcomeArray[name].text);
+  }
+}
+
+
+/** List welcome messages.
+ * @param[in] sptr Client requesting the listing.
+ * @param[in] connect When non zero do not report no welcome is set
+ * @return Zero.
+ */
+int
+welcome_list(struct Client *sptr, int connect)
+{
+  int found = 0, local = 0, name;
+
+  assert(NULL != sptr);
+
+  /* loop over all entries - range 0 to 2 * max - 1 */
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* local entries now */
+    if (name == WELCOME_MAX_ENTRIES)
+      local = 1;
+
+    /* not set or empty - skip */
+    /* TODO: EmptyString? */
+    if (WelcomeArray[name].timestamp == 0 || *WelcomeArray[name].text == 0)
+      continue;
+
+    /* got one */
+    found++;
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :[%s] %s",
+      sptr, local ? cli_name(&me) : feature_str(FEAT_NETWORK), WelcomeArray[name].text);
+  }
+
+  /* nothing set */
+  if (!found && !connect)
+    sendcmdto_one(&me, CMD_NOTICE, sptr, "%C :No welcome message set.", sptr);
+  
+  return 0;
+}
+
+
+/** Statistics callback to list Welcome messages.
+ * @param[in] sptr Client requesting statistics.
+ * @param[in] sd Stats descriptor for request (ignored).
+ * @param[in] param Extra parameter from user (ignored).
+ */
+void
+welcome_stats(struct Client *sptr, const struct StatDesc *sd, char *param)
+{
+  int name, local = 0;
+
+  assert(NULL != sptr);
+
+  /* loop over all entries - range 0 to 2 * max - 1*/
+  for (name = 0; name <= 2 * WELCOME_MAX_ENTRIES - 1; name++) {
+
+    /* local entries now */
+    if (name == WELCOME_MAX_ENTRIES)
+      local = 1;
+
+    /* not set */
+    if (WelcomeArray[name].timestamp == 0)
+      continue;
+
+    /* send it */
+    send_reply(sptr, RPL_STATSWELCOME,
+      local ? name + 1 - WELCOME_MAX_ENTRIES : name + 1,
+      local ? cli_name(&me) : "*",
+      WelcomeArray[name].who, WelcomeArray[name].timestamp,
+      EmptyString(WelcomeArray[name].text)  ? "<Empty>" : WelcomeArray[name].text);
+  }
+}

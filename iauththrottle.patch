Implements support for unthrottling specific IPs by resetting their
connection attempts to 0 with the IAuth command "T".

diff -r af93be0cd36e doc/readme.iauth
--- a/doc/readme.iauth	Wed Feb 12 00:52:12 2014 +0100
+++ b/doc/readme.iauth	Fri Feb 14 15:06:00 2014 +0100
@@ -495,3 +495,12 @@
 Comments: Used by the iauth instance to set a user's spoof host.
 Compatibility: This is an Undernet extension and ircd does not support
   this message.
+
+T - Unthrottle client
+Syntax: T <id> <remoteip> <remoteport>
+Example: T 5 192.168.1.10 23367
+Comments: Unthrottle the client by resetting the connection attempt counter
+  for this IP
+Compatibility: This is an Undernet extension and ircd does not support
+  this message.
+
diff -r af93be0cd36e doc/readme.snircd
--- a/doc/readme.snircd	Wed Feb 12 00:52:12 2014 +0100
+++ b/doc/readme.snircd	Fri Feb 14 15:06:00 2014 +0100
@@ -292,6 +292,8 @@
 
  * CLOAK: Allows finding spam relays using selectively visible clients.
 
+ * THROTTLE: Lets IAuth throttle/unthrottle specific IP addresses.
+
 - configuration options ------------------------------------------------
 
 Privileges for opers:
diff -r af93be0cd36e include/IPcheck.h
--- a/include/IPcheck.h	Wed Feb 12 00:52:12 2014 +0100
+++ b/include/IPcheck.h	Fri Feb 14 15:06:00 2014 +0100
@@ -23,5 +23,6 @@
 extern int IPcheck_remote_connect(struct Client *cptr, int is_burst);
 extern void IPcheck_disconnect(struct Client *cptr);
 extern unsigned short IPcheck_nr(struct Client* cptr);
+extern void ip_registry_reset_attempts(const struct irc_in_addr *addr);
 
 #endif /* INCLUDED_ipcheck_h */
diff -r af93be0cd36e ircd/IPcheck.c
--- a/ircd/IPcheck.c	Wed Feb 12 00:52:12 2014 +0100
+++ b/ircd/IPcheck.c	Fri Feb 14 15:06:00 2014 +0100
@@ -259,6 +259,19 @@
   timer_add(timer_init(&expireTimer), ip_registry_expire, 0, TT_PERIODIC, 60);
 }
 
+/** Reset connect attempts counter in an IPRegistryEntry to circumvent throttling.
+ * @param[in] addr Address of client.
+ */
+void ip_registry_reset_attempts(const struct irc_in_addr *addr)
+{
+  struct IPRegistryEntry* entry = ip_registry_find(addr);
+
+  if (0 == entry)
+    return;
+
+  entry->attempts = 0;
+}
+
 /** Check whether a new connection from a local client should be allowed.
  * A connection is rejected if someone from the "same" address (see
  * ip_registry_find()) connects IPCHECK_CLONE_LIMIT times, each time
@@ -267,7 +280,7 @@
  * @param[out] next_target_out Receives time to grant another free target.
  * @return Non-zero if the connection is permitted, zero if denied.
  */
-int ip_registry_check_local(const struct irc_in_addr *addr, time_t* next_target_out)
+static int ip_registry_check_local(const struct irc_in_addr *addr, time_t* next_target_out)
 {
   struct IPRegistryEntry* entry = ip_registry_find(addr);
   unsigned int free_targets = STARTTARGETS;
@@ -372,7 +385,7 @@
  * so the client's address is not penalized for the failure.
  * @param[in] addr Address of rejected client.
  */
-void ip_registry_connect_fail(const struct irc_in_addr *addr)
+static void ip_registry_connect_fail(const struct irc_in_addr *addr)
 {
   struct IPRegistryEntry* entry = ip_registry_find(addr);
   if (entry && 0 == --entry->attempts) {
diff -r af93be0cd36e ircd/s_auth.c
--- a/ircd/s_auth.c	Wed Feb 12 00:52:12 2014 +0100
+++ b/ircd/s_auth.c	Fri Feb 14 15:06:00 2014 +0100
@@ -2135,6 +2135,22 @@
   return 0;
 }
 
+/** Unthrottles the specified client by resetting the connection attempts
+ *  on the IP address
+ * @param[in] iauth Active IAuth session.
+ * @param[in] cli Client referenced by command.
+ * @param[in] parc Number of parameters (2).
+ * @param[in] params Operation type and IP address.
+ * @return Zero.
+ */
+static int iauth_cmd_unthrottle(struct IAuth *iauth, struct Client *cli,
+                            int parc, char **params)
+{
+  ip_registry_reset_attempts(&cli_ip(cli));
+
+  return 0;
+}
+
 /** Parse a \a message from \a iauth.
  * @param[in] iauth Active IAuth session.
  * @param[in] message Message to be parsed.
@@ -2160,6 +2176,7 @@
   case 's': handler = iauth_cmd_newstats; has_cli = 0; break;
   case 'S': handler = iauth_cmd_stats; has_cli = 0; break;
   case 'X': handler = iauth_cmd_xquery; has_cli = 0; break;
+  case 'T': handler = iauth_cmd_unthrottle; has_cli = 1; break;
   case 'o': handler = iauth_cmd_username_forced; has_cli = 1; break;
   case 'U': handler = iauth_cmd_username_good; has_cli = 1; break;
   case 'u': handler = iauth_cmd_username_bad; has_cli = 1; break;

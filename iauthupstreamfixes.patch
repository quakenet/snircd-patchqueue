Contains some upstream IAuth fixes:

ircu subversion IDs:

1797, 1843, 1911, 1914, 1924

ircu git IDs:

29a8ddb8ef24a23c7aa8d31b90474a6ec536e4cc, 8a0fce5ce44018405ec3aab7115f7b7028c90329, 3cfdd224928b767bf33e7de2507b6cad3bcfe3ba

diff -r 0bdd5b4b388b ChangeLog
--- a/ChangeLog	Mon Jul 08 19:47:15 2013 +0200
+++ b/ChangeLog	Mon Jul 08 19:49:02 2013 +0200
@@ -1,3 +1,62 @@
+2011-01-19  Michael Poole <mdpoole@troilus.org>
+
+	* doc/readme.iauth: Document the new 'd' IAuth command.
+
+	* ircd/s_auth.c (AuthRequestFlag): Add "soft done" flag.
+	(auth_ping_timeout): Do not impose Authorization Timeout on
+	clients with the "soft done" flag set.
+	(iauth_cmd_soft_done): New IAuth command handler.
+	(iauth_parse): Call it.
+
+2011-01-19  Michael Poole <mdpoole@troilus.org>
+
+	* ircd/s_auth.c (start_auth): Call start_dns_query() and
+	start_auth_query() after start_iauth_query() rather than
+	before.
+
+2010-01-01  Michael Poole <mdpoole@troilus.org>
+
+	* ircd/s_auth.c (iauth_do_spawn): Add debug output to diagnose
+	which system call might be failing.
+	(auth_spawn): Avoid reading past the end of iauth->i_argv[].  When
+	discarding an existing IAuth instance, use auth_close_unused() to
+	close the sockets and avoid leaking memory.
+
+2009-07-04  Michael Poole <mdpoole@troilus.org>
+
+	* ircd/s_auth.c (find_conf_client): New function.
+	(preregister_user): Use it to avoid assigning a second conf class
+	on client connection.
+	(auth_ping_timeout): Send the "T" message only if we do not kill
+	the client (and thus send a "D" message).
+	(auth_find_classs_conf): Do not allow IAuth to select a disabled
+	class.  Unlink new conf items from GlobalConfList.
+	(iauth_cmd_done_client): Handle failures from attach_conf().
+	(iauth_parse): Behave decently when a client is killed by the
+	message handler.
+
+	* tools/iauth-test (%handlers): Add entries to help test this.
+
+2009-03-25  Michael Poole <mdpoole@troilus.org>
+
+	* ircd/s_auth.c (iauth_cmd_hostname): Properly assign the spoofed
+	hostname (yea, even as the "real" host) in the hurry state.
+
+	* tools/iauth-test: Add reminder about perl's RTMIN signal and a
+	new handler to exercise the N command in the hurry state.
+
+2007-11-17  Michael Poole <mdpoole@troilus.org>
+
+	* ircd/s_auth.c (iauth_disconnect): Avoid destroying invalid
+	sockets.
+	(iauth_stderr_callback): Disconnect iauth child if stderr has
+	EOF (in case stdin notification is delayed somehow).
+
+2007-04-01  J. R. Lenz <ralf@starshadow.com>
+
+	* ircd/s_user.c (register_user): Check for host-hiding when fully
+	registering a user.  [Comment added by Entrope.]
+
 2007-03-09  Michael Poole <mdpoole@troilus.org>
 
 	* include/patchlevel.h (PATCHLEVEL): Bump for u2.10.12.10 release.
diff -r 0bdd5b4b388b doc/readme.iauth
--- a/doc/readme.iauth	Mon Jul 08 19:47:15 2013 +0200
+++ b/doc/readme.iauth	Mon Jul 08 19:49:02 2013 +0200
@@ -408,6 +408,18 @@
 Comments: Indicates that the specified client should be disconnected
   for the reason given.  Operators should be notified.
 
+d - "Soft" Done Checking
+Syntax: d <id> <remoteip> <remoteport>
+Example: d 5 192.168.1.10 23367
+States: REGISTER, HURRY
+Next State: -
+Comments: Indicates that the iauth instance has no objection to letting
+  the specified client onto the network, but that some further work is
+  in process.  In particular, an account stamp and/or connection class
+  might be available later.
+Compatibility: This is an Undernet extension and ircd does not support
+  this message.
+
 D - Done Checking
 Syntax: D <id> <remoteip> <remoteport> [class]
 Example: D 5 192.168.1.10 23367
diff -r 0bdd5b4b388b ircd/s_auth.c
--- a/ircd/s_auth.c	Mon Jul 08 19:47:15 2013 +0200
+++ b/ircd/s_auth.c	Mon Jul 08 19:49:02 2013 +0200
@@ -83,6 +83,7 @@
     AR_IAUTH_HURRY,     /**< we told iauth to hurry up */
     AR_IAUTH_USERNAME,  /**< iauth sent a username (preferred or forced) */
     AR_IAUTH_FUSERNAME, /**< iauth sent a forced username */
+    AR_IAUTH_SOFT_DONE, /**< iauth has no objection to client */
     AR_PASSWORD_CHECKED, /**< client password already checked */
     AR_NUM_FLAGS
 };
@@ -435,6 +436,26 @@
   return 1; /* it's a valid hostname */
 }
 
+/** Check whether a client already has a CONF_CLIENT configuration
+ * item.
+ *
+ * @return A pointer to the client's first CONF_CLIENT, or NULL if
+ *   there are none.
+ */
+static struct ConfItem *find_conf_client(struct Client *cptr)
+{
+  struct SLink *list;
+
+  for (list = cli_confs(cptr); list != NULL; list = list->next) {
+    struct ConfItem *aconf;
+    aconf = list->value.aconf;
+    if (aconf->status & CONF_CLIENT)
+      return aconf;
+  }
+
+  return NULL;
+}
+
 /** Assign a client to a connection class.
  * @param[in] cptr Client to assign to a class.
  * @return Zero if client is kept, CPTR_KILLED if rejected.
@@ -447,6 +468,10 @@
   ircd_strncpy(cli_user(cptr)->host, cli_sockhost(cptr), HOSTLEN);
   ircd_strncpy(cli_user(cptr)->realhost, cli_sockhost(cptr), HOSTLEN);
 
+  if (find_conf_client(cptr)) {
+    return 0;
+  }
+
   switch (conf_check_client(cptr))
   {
   case ACR_OK:
@@ -740,11 +765,12 @@
 
   /* Check for iauth timeout. */
   if (FlagHas(&auth->flags, AR_IAUTH_PENDING)) {
-    sendto_iauth(cptr, "T");
-    if (IAuthHas(iauth, IAUTH_REQUIRED)) {
+    if (IAuthHas(iauth, IAUTH_REQUIRED)
+        && !FlagHas(&auth->flags, AR_IAUTH_SOFT_DONE)) {
       sendheader(cptr, REPORT_FAIL_IAUTH);
       return exit_client_msg(cptr, cptr, &me, "Authorization Timeout");
     }
+    sendto_iauth(cptr, "T");
     FlagClr(&auth->flags, AR_IAUTH_PENDING);
     return check_auth_finished(auth);
   }
@@ -969,12 +995,6 @@
   }
   auth->port = remote.port;
 
-  /* Try to start DNS lookup. */
-  start_dns_query(auth);
-
-  /* Try to start ident lookup. */
-  start_auth_query(auth);
-
   /* Set required client inputs for users. */
   if (IsUserPort(client)) {
     cli_user(client) = make_user(client);
@@ -986,6 +1006,12 @@
     start_iauth_query(auth);
   }
 
+  /* Try to start DNS lookup. */
+  start_dns_query(auth);
+
+  /* Try to start ident lookup. */
+  start_auth_query(auth);
+
   /* Add client to GlobalClientList. */
   add_client_to_list(client);
 
@@ -1138,13 +1164,17 @@
 
   /* Attempt to allocate a pair of sockets. */
   res = os_socketpair(s_io);
-  if (res)
-    return errno;
+  if (res) {
+    res = errno;
+    Debug((DEBUG_INFO, "Unable to create IAuth socketpair: %s", strerror(res)));
+    return res;
+  }
 
   /* Mark the parent's side of the pair (element 0) as non-blocking. */
   res = os_set_nonblocking(s_io[0]);
   if (!res) {
     res = errno;
+    Debug((DEBUG_INFO, "Unable to make IAuth socket non-blocking: %s", strerror(res)));
     close(s_io[1]);
     close(s_io[0]);
     return res;
@@ -1155,6 +1185,7 @@
                    SS_CONNECTED, SOCK_EVENT_READABLE, s_io[0]);
   if (!res) {
     res = errno;
+    Debug((DEBUG_INFO, "Unable to register IAuth socket: %s", strerror(res)));
     close(s_io[1]);
     close(s_io[0]);
     return res;
@@ -1164,6 +1195,7 @@
   res = os_socketpair(s_err);
   if (res) {
     res = errno;
+    Debug((DEBUG_INFO, "Unable to create IAuth stderr: %s", strerror(res)));
     socket_del(i_socket(iauth));
     close(s_io[1]);
     close(s_io[0]);
@@ -1174,6 +1206,7 @@
   res = os_set_nonblocking(s_err[0]);
   if (!res) {
     res = errno;
+    Debug((DEBUG_INFO, "Unable to make IAuth stderr non-blocking: %s", strerror(res)));
     close(s_err[1]);
     close(s_err[0]);
     socket_del(i_socket(iauth));
@@ -1187,6 +1220,7 @@
                    SS_CONNECTED, SOCK_EVENT_READABLE, s_err[0]);
   if (!res) {
     res = errno;
+    Debug((DEBUG_INFO, "Unable to register IAuth stderr: %s", strerror(res)));
     close(s_err[1]);
     close(s_err[0]);
     socket_del(i_socket(iauth));
@@ -1200,6 +1234,7 @@
   if (cpid < 0) {
     /* Error forking the child, still in parent. */
     res = errno;
+    Debug((DEBUG_INFO, "Unable to fork IAuth child: %s", strerror(res)));
     socket_del(i_stderr(iauth));
     close(s_err[1]);
     close(s_err[0]);
@@ -1259,17 +1294,15 @@
         same = 0;
     }
     /* Check that we have no more pre-existing arguments. */
-    if (iauth->i_argv[ii])
+    if (same && iauth->i_argv[ii])
       same = 0;
-    /* If they are the same and still connected, clear the "closing" flag and exit.*/
+    /* If they are the same and still connected, clear the "closing" flag and exit. */
     if (same && i_GetConnected(iauth)) {
+      Debug((DEBUG_INFO, "Reusing existing IAuth process"));
       IAuthClr(iauth, IAUTH_CLOSING);
       return 2;
     }
-    /* Deallocate old argv elements. */
-    for (ii = 0; iauth->i_argv[ii]; ++ii)
-      MyFree(iauth->i_argv[ii]);
-    MyFree(iauth->i_argv);
+    auth_close_unused();
   }
 
   /* Need to initialize a new connection. */
@@ -1299,18 +1332,22 @@
  */
 static void iauth_disconnect(struct IAuth *iauth)
 {
-  if (!i_GetConnected(iauth))
+  if (iauth == NULL)
     return;
 
   /* Close main socket. */
-  close(s_fd(i_socket(iauth)));
-  socket_del(i_socket(iauth));
-  s_fd(i_socket(iauth)) = -1;
+  if (s_fd(i_socket(iauth)) != -1) {
+    close(s_fd(i_socket(iauth)));
+    socket_del(i_socket(iauth));
+    s_fd(i_socket(iauth)) = -1;
+  }
 
   /* Close error socket. */
-  close(s_fd(i_stderr(iauth)));
-  socket_del(i_stderr(iauth));
-  s_fd(i_stderr(iauth)) = -1;
+  if (s_fd(i_stderr(iauth)) != -1) {
+    close(s_fd(i_stderr(iauth)));
+    socket_del(i_stderr(iauth));
+    s_fd(i_stderr(iauth)) = -1;
+  }
 }
 
 /** Close all %IAuth connections marked as closing. */
@@ -1706,6 +1743,14 @@
   }
   /* Set hostname from params. */
   ircd_strncpy(cli_sockhost(cli), params[0], HOSTLEN);
+  /* If we have gotten here, the user is in a "hurry" state and has
+   * been pre-registered.  Their hostname was set during that, and
+   * needs to be overwritten now.
+   */
+  if (FlagHas(&auth->flags, AR_IAUTH_HURRY)) {
+    ircd_strncpy(cli_user(cli)->host, cli_sockhost(cli), HOSTLEN);
+    ircd_strncpy(cli_user(cli)->realhost, cli_sockhost(cli), HOSTLEN);
+  }
   return 1;
 }
 
@@ -1767,7 +1812,7 @@
 
   /* Make sure the configuration class is valid. */
   class = find_class(class_name);
-  if (!class)
+  if (!class || !class->valid)
     return NULL;
 
   /* Look for an existing ConfItem for the class. */
@@ -1784,6 +1829,13 @@
                            ConClass(class));
       return NULL;
     }
+    /* make_conf() "helpfully" links the conf into GlobalConfList,
+     * which we do not want, so undo that.  (Ugh.)
+     */
+    if (aconf == GlobalConfList) {
+      GlobalConfList = aconf->next;
+    }
+    /* Back to business as usual. */
     aconf->conn_class = class;
     aconf->next = aconf_list;
     aconf_list = aconf;
@@ -1792,12 +1844,28 @@
   return aconf;
 }
 
+/** Tentatively accept a client in IAuth.
+ * @param[in] iauth Active IAuth session.
+ * @param[in] cli Client referenced by command.
+ * @param[in] parc Number of parameters.
+ * @param[in] params Optional class name for client.
+ * @return Negative (CPTR_KILLED) if the connection is refused, one otherwise.
+ */
+static int iauth_cmd_soft_done(struct IAuth *iauth, struct Client *cli,
+			       int parc, char **params)
+{
+  /* Clear iauth pending flag. */
+  assert(cli_auth(cli) != NULL);
+  FlagSet(&cli_auth(cli)->flags, AR_IAUTH_SOFT_DONE);
+  return 1;
+}
+
 /** Accept a client in IAuth.
  * @param[in] iauth Active IAuth session.
  * @param[in] cli Client referenced by command.
  * @param[in] parc Number of parameters.
  * @param[in] params Optional class name for client.
- * @return One.
+ * @return Negative (CPTR_KILLED) if the connection is refused, one otherwise.
  */
 static int iauth_cmd_done_client(struct IAuth *iauth, struct Client *cli,
 				 int parc, char **params)
@@ -1813,9 +1881,24 @@
     struct ConfItem *aconf;
 
     aconf = auth_find_class_conf(params[0]);
-    if (aconf)
-      attach_conf(cli, aconf);
-    else
+    if (aconf) {
+      enum AuthorizationCheckResult acr;
+
+      acr = attach_conf(cli, aconf);
+      switch (acr) {
+      case ACR_OK:
+        /* There should maybe be some way to set FLAG_DOID here.. */
+        break;
+      case ACR_TOO_MANY_IN_CLASS:
+        ++ServerStats->is_ref;
+        return exit_client(cli, cli, &me,
+                           "Sorry, your connection class is full - try "
+                           "again later or try another server");
+      default:
+        log_write(LS_IAUTH, L_ERROR, 0, "IAuth: Unexpected AuthorizationCheckResult %d from attach_conf()", acr);
+        break;
+      }
+    } else
       sendto_opmask_butone_ratelimited(NULL, SNO_AUTH, &warn_time,
                                        "iauth tried to use undefined class [%s]",
                                        params[0]);
@@ -1829,7 +1912,8 @@
  * @param[in] cli Client referenced by command.
  * @param[in] parc Number of parameters.
  * @param[in] params Account name and optional class name for client.
- * @return Non-zero if \a cli authorization should be checked for completion.
+ * @return Negative if the connection is refused, otherwise non-zero
+ *   if \a cli authorization should be checked for completion.
  */
 static int iauth_cmd_done_account(struct IAuth *iauth, struct Client *cli,
 				  int parc, char **params)
@@ -1948,6 +2032,7 @@
   case 'I': handler = iauth_cmd_ip_address; has_cli = 1; break;
   case 'M': handler = iauth_cmd_usermode; has_cli = 1; break;
   case 'C': handler = iauth_cmd_challenge; has_cli = 1; break;
+  case 'd': handler = iauth_cmd_soft_done; has_cli = 1; break;
   case 'D': handler = iauth_cmd_done_client; has_cli = 1; break;
   case 'R': handler = iauth_cmd_done_account; has_cli = 1; break;
   case 'k': /* The 'k' command indicates the user should be booted
@@ -2015,7 +2100,7 @@
 	/* Report mismatch to iauth. */
 	sendto_iauth(cli, "E Mismatch :[%s] != [%s]", params[1],
 		     ircd_ntoa(&cli_ip(cli)));
-      else if (handler(iauth, cli, parc - 3, params + 3))
+      else if (handler(iauth, cli, parc - 3, params + 3) > 0)
 	/* Handler indicated a possible state change. */
 	check_auth_finished(auth);
     }
@@ -2151,14 +2236,17 @@
   assert(0 != iauth);
 
   switch (ev_type(ev)) {
+  case ET_DESTROY:
+    /* We do not restart iauth here: the stdout handler does that for us. */
+    break;
   case ET_READ:
     iauth_read_stderr(iauth);
     break;
   case ET_ERROR:
     log_write(LS_IAUTH, L_ERROR, 0, "IAuth stderr error: %s", strerror(ev_data(ev)));
-    /* and fall through to the ET_EOF/ET_DESTROY case */
-  case ET_DESTROY:
+    /* and fall through to the ET_EOF case */
   case ET_EOF:
+    iauth_disconnect(iauth);
     break;
   default:
     assert(0 && "Unrecognized event type");
diff -r 0bdd5b4b388b ircd/s_user.c
--- a/ircd/s_user.c	Mon Jul 08 19:47:15 2013 +0200
+++ b/ircd/s_user.c	Mon Jul 08 19:49:02 2013 +0200
@@ -466,6 +466,12 @@
     ++UserStats.inv_clients;
   if (IsOper(sptr))
     ++UserStats.opers;
+  /* If they get both +x and an account during registration, hide
+   * their hostmask here.  Calling hide_hostmask() from IAuth's
+   * account assignment causes a numeric reply during registration.
+   */
+  if (HasHiddenHost(sptr))
+    hide_hostmask(sptr, FLAG_HIDDENHOST);
 
   tmpstr = umode_str(sptr, 0);
   int ipv6andopername[] = {FLAG_IPV6,FLAG_OPERNAME};
diff -r 0bdd5b4b388b tools/iauth-test
--- a/tools/iauth-test	Mon Jul 08 19:47:15 2013 +0200
+++ b/tools/iauth-test	Mon Jul 08 19:49:02 2013 +0200
@@ -26,6 +26,8 @@
 # SIGRTMIN + 2 -> Set policy options ('O').
 # SIGRTMIN + 3 -> Simulate config change ('a', 'A').
 # SIGRTMIN + 4 -> Simulate statistics change ('s', 'S').
+# Note that Perl's value for SIGRTMIN may be different than your OS's.
+# The easiest check is by running "perl -V:sig_num -V:sig_name".
 
 # In the following discussion, sX means message X from the server, and
 # iX means message X from iauth.  The hard part is the ordering of
@@ -153,6 +155,8 @@
                 '127.0.0.2'  => { C_reply => 'R account-1' },
                 '127.0.0.3'  => { C_reply => 'k' },
                 '127.0.0.4'  => { C_reply => 'K' },
+                '127.0.0.5'  => { C_reply => 'D Specials' },
+                '127.0.0.6'  => { C_reply => 'R account-1 Specials' },
                 '127.0.0.15' => { },
                 '127.0.0.16' => { H_reply => 'D' },
                 '127.0.0.17' => { H_reply => 'R account-2' },
@@ -173,6 +177,7 @@
                 '127.0.2.0'  => { C_reply => 'N iauth.assigned.host',
                                   H_reply => 'D' },
                 '127.0.2.1'  => { C_reply => \&ip_change },
+                '127.0.2.2'  => { H_reply => \&host_change_and_done },
                 # 127.0.3.x: iC/sP functionality.
                 '127.0.3.0'  => { C_reply => 'C :Please enter the password.',
                                   P_reply => \&passwd_check },
@@ -196,6 +201,16 @@
     reply 'D', $client;
 }
 
+# Note to potential debuggers: You will have to change the iauth
+# policy before this (or any other H_reply hooks) will have any
+# effect.  Do this by sending two signals of $SIG{RTMIN+2} to the
+# iauth-test process, as noted near the beginning of this script.
+sub host_change_and_done ($$) {
+    my ($client, $extra) = @_;
+    reply 'N iauth.assigned.host', $client;
+    reply 'D', $client;
+}
+
 sub passwd_check ($$) {
     my ($client, $extra) = @_;
     if ($extra eq 'secret') {
